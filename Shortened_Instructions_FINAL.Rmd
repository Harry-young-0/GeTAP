---
title: "Overall Workflow"
output:
  html_document:
    df_print: paged
  pdf_document: default
---
TESTING: Your gene name is YOUR_GENE_NAME. If this still reads "your gene name" not a specific gene you have chosen (for example KEAP1), Please try the ctrl-f step again 

###Please email me at harry.young@bristol.ac.uk with any questions about the pipeline

# STEP 0: Notes on using this notebook
Prerequisites to load in :
 (these are listed here but are also dotted throughout where I've forgotten to remove them!) 
 NOTE: Now split into two boxes, first installs all packages needed first: INCOMPLETE, ADD THIS BOX IN
```{r}
# #First line to clear out environment
# rm(list=ls())
# # Install all required packages:
# install.packages("tidyverse")
# install.packages("circlize")
# install.packages("devtools")
# install.packages("viridis")
# install.packages("RColorBrewer")
# install.packages("BiocManager")
# install.packages("ggpubr")
# library(circlize)
# library(tidyverse)
# library(viridis)
# library(RColorBrewer)
# library(ggpubr)
# 
# library(devtools)
# devtools::install_github("CBIIT/LDlinkR")
# devtools::install_github("mrcieu/ieugwasr")
# library(LDlinkR)# uncomment
# library(ieugwasr)
# library(BiocManager)
# BiocManager::install("biomaRt")
# library(biomaRt)
# #library(stringi)
# library(dplyr)
# library(ieugwasr)

```

## Notes
DO NOT SIMPLY PRESS "Knit" this notebook is designed to guide you through step by step using "chunks" which are embedded sections of R code. 

For those who have never done any R, hopefully the code is commented well enough to understand but I would highly recommend reading up on basic R syntax before starting. Just google it. There's endless resources - ADD IN MY RECOMENDATIONS HERE MAYBE?.  

I've tried to use descriptive names for things so it's easier to follow but I do use "df" as shorthand for the current dataframe we're working with. (a dataframe essentially being a table)

This notebook is primarily a way of easily seeing what I have done in the pipeline It is important to pay attention to what the block of code is doing and change appropriately for each gene of interest. This notebook is setup for YOUR_GENE_NAME (YOUR_GENE_NAME) so all of the names and working directories reflect this. To change this to your gene of interest simply use ctrl-f and replace all "YOUR_GENE_NAME" with "your gene of interest". Now all the instructions should reflect your gene of interest  - 309 occurences should be changed.

At the start of most coding blocks I have added in a read_csv line that simply reads in the dataframe that you have just made and saved in the previous steps. This avoids any issues you might find of RStudio keeping track of which is which. Also, this allows you to run through the code in full once and then from then on you can rerun specific STEPS if needed without the need for doing the whole thing. This is particularly useful for the plotting section as it allows you to have your dataframe read in and then you can add or delete as many different forms of plots as you like. I have my favourite set in there at the moment but this is subject to change!

INCOMPLETE = Skip this section for the moment

COME BACK TO THIS = Add in extra here if needed

A lot of this code is probably less efficient than it could be. In general I've found it difficult to find the correct vectorised functions to quickly do what I want. For this reason I find myself leaning heavily on more generic computing logic using 'for' and 'if' loops. This does work but please be patient with certain chunks as they may take a little while to run. Any tips and improvements are very welcome. Please do email me :) . 

##File Setup

Finally, it is important to set up a file system similar to what I've done for it to run automatically. C:/Users/Harry Young/Documents/Local Wokr/GENENAME_test/ containing Gtex and LDMatrix folders, each with Plots folder within. This will make the ctrl-f replace function work well. If you don't want to use your desktop you can ctrl-f and replace "C:/Users/Harry Young/Documents/Local Wokr/" with whatever head folder you want: e.g. "~/OneDrive - University of Bristol/PhD/Epidemiology/" 

Here is an optional chunk to load in all the directories you'll need to run this notebook as is (as above simply change C:/Users/Harry Young/Documents/Local Wokr/) to whatever your file path is to the master folder:

INCOMPLETE : add a repository for Full_trait_database and Full_Tissue_database (and egene data if needed)


For my databases, I have made them freely available but obviously where you save them to look up, modify and add to is up to you. So use ctrl-f to find all occurences of 'setwd("C:/Users/Harry Young/Documents/Local Wokr/Trait and Tissue Groups")' and change to wherever you have saved teh tissue and trait databases.

If you'd like to add your changes tot he online database for others to use please email me your updated csv and I'll add to it.

Any issues, first check the common errors section at the end of this document!

# STEP 1: Organising each dataset
## GTEx data - online available (source code: GtexPSandPHEWAS_merger.R):
### Just to clarify I find it easiest to continue through with one data set at a time.
### So, I'll do the Gtex, gtex merge and plotting, then loop back and do gnomad. 
### This is a preference thing but the code will work so long as you follow the step order.
The goal here is to look at and get familiar with the data whilst re-organising it in such a way that it makes your life easier when it comes to merging the data later on.

I would suggest setting up a folder to run all of this into, copying it over to backup files as you go, here I've named in YOUR_GENE_NAME_test:

e.g, use the following code in every chunk:
```{r}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
```

Firstly we read in the dataframe of interest and do some initial clean-up steps:

To read in the dataframe first search your gene of interest into Gtex portal. Then click significant single-tissue eQTL and download the csv. Rename the file Gtex_YOUR_GENE_NAME_START.
```{r Initial load and clean}

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
Gtex_YOUR_GENE_NAME = read_csv("Gtex_YOUR_GENE_NAME_START.csv")

df = Gtex_YOUR_GENE_NAME
head(df)  # This function just shows us the top few rows of the dataframe to see what we're looking at

### Seprates out the variant ID into usable columns
df = df %>%
  separate(`Variant Id`, c("chr_gtex", "position_gtex", "a", "b", "build_gtex"), remove = F) 
  #remove = F keeps the original column too

#Finally quickly altering column name SNP ID to rsid for simplicity of code:
df = df%>%
  rename(rsid = `SNP Id`)

head(df) 

#Also clear up any NA rsids that have snuck through
df = df[which(is.na(df$rsid)==F),]

```

So, now we have a Gtex table with a seperated location and mutation column for easy use later on. IMPORTANT NOTE: a = reference allele and b = Effect or Alternate Allele. In other words, the change in expression NES occurs in patients with the mutation at location x from a to b.

I setup a modulus of NES using the following (can be useful for ordering the dataframe later on): 
```{r Modulus NES setup}
df$`|NES|` = sqrt(df$NES*df$NES)
head(df)
tail(df) # Check that |NES| = NES in all cases 
```

Save this file as "cleaned" data:
```{r Save clean data}
# setwd repeated here 
# setwd("~/OneDrive - University of Bristol/PhD/Epidemiology/Quantitative and Qualitative SNP lists")
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_excel_csv(df, "YOUR_GENE_NAME_Gtex_cleaned.csv")

```

Then we need to isolate the unique SNPs for searching in the ieugwasR package:

```{r Unique SNPs from Gtex}
unique_YOUR_GENE_NAME_Gtex_snps = unique(df$rsid)
# setwd("~/OneDrive - University of Bristol/PhD/Epidemiology/Quantitative and Qualitative SNP lists")
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write.table(unique_YOUR_GENE_NAME_Gtex_snps, "unique_YOUR_GENE_NAME_Gtex_snps.csv", sep="\t", row.names=FALSE, col.names=FALSE) # saving the file
```


# Step 1b: Assess linkage disequilibrium
This is quite a complicated series of steps, going from the matrix file to clearing up linked snps. (This can also be done retrospectively). I've tried to make it as simple as possible by splitting it into copied sets of the same chunks of code for d prime and r2 metrics of linkage disequilibrium. 2.1 = dprime 2.2 = r2. If you get lost simply clear your environment and go from the top of this step. 
## querying LDMatrix - DELETE STEPS 2.1 and 2.2 if #SNPS>1000
#####IMPORTANT BEFORE YOU START: Check the length (number of rows) of your unique_snp_list. if <700, continue with 2.1 and 2.2 AND skip 2.3. If >1000 move to 2.3 SKIPPING 2.1 and 2.2
##2.1 Assess Linkage disequilibrium (D')
First step is to search your list of snps (unique_YOUR_GENE_NAME_Gtex_snps) into LDMatrix to get an interactive plot of linkage disequilibrium in your snp set. https://ldlink.nci.nih.gov/?tab=ldmatrix 

This is an automatable step but I think it is important to see the matrix plot in LD matrix WHEN YOU CAN (<300 online) , open your dataframe of unique SNPs in excel, copy and paste the column into the query box on LD matrix, tick all populations (or even just european) and click calculate.

From this you should get a nice matrix plot of all of of the linkage between your SNPs. Save a copy of this into the LDMatrix/Plots folder and download the two csvs for D' and R2

Alternatively use these lines of code. You'll have to ask for a "token" from the LD link website: https://ldlink.nci.nih.gov/?tab=apiaccess and also install the LDlinkR package using the commented lines.
### Step a - get matrices of R2 and dprime
```{r Automated r2 and d prime START dataset}

if(length(unique_YOUR_GENE_NAME_Gtex_snps)<700){

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/LDMatrix")
YOUR_GENE_NAME_r2 = LDmatrix(unique_YOUR_GENE_NAME_Gtex_snps, pop = "EUR", r2d = "r2", token ="f0d7bc798f5c")
write_csv(YOUR_GENE_NAME_r2, "YOUR_GENE_NAME_r2.csv")



# open up the .csv file from the website as tab-deliminated 
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/LDMatrix")
YOUR_GENE_NAME_r2 = read_csv("YOUR_GENE_NAME_r2.csv")
head(YOUR_GENE_NAME_r2)


for(n in 1:ncol(YOUR_GENE_NAME_r2)){#         LOOP to create a df of NA and values above 0.5 - CHANGE THIS CUTOFF TO WHAT YOU WANT
  if(n==1){ # First column is the rsid so skip it using 'next'
    next
  }
  else if(n==2){linked0.5 = YOUR_GENE_NAME_r2[which(YOUR_GENE_NAME_r2[,n]>=0.5),] # For the first column setup a new df to write to, called 'linked0.5'
    linked0.5 = linked0.5[,c(1,n)]
  }
  else{
    linked0.5_temp =YOUR_GENE_NAME_r2[which(YOUR_GENE_NAME_r2[,n]>=0.5),] # Each loop you are making a temporary file 'linked0.5_temp', 
    linked0.5_temp = linked0.5_temp[,c(1,n)] 
    linked0.5 = merge(linked0.5, linked0.5_temp, all.x=T, all.y=T) # Then merging to the original linked0.5 file
  }
}

head(linked0.5)

#Repeated for 0.75
for(n in 1:ncol(YOUR_GENE_NAME_r2)){#         LOOP to create a df of NA and values above 0.5 - CHANGE THIS CUTOFF TO WHAT YOU WANT
  if(n==1){ # First column is the rsid so skip it using 'next'
    next
  }
  else if(n==2){linked0.75 = YOUR_GENE_NAME_r2[which(YOUR_GENE_NAME_r2[,n]>=0.75),] # For the first column setup a new df to write to, called 'linked0.75'
    linked0.75 = linked0.75[,c(1,n)]
  }
  else{
    linked0.75_temp =YOUR_GENE_NAME_r2[which(YOUR_GENE_NAME_r2[,n]>=0.75),] # Each loop you are making a temporary file 'linked0.75_temp', 
    linked0.75_temp = linked0.75_temp[,c(1,n)] 
    linked0.75 = merge(linked0.75, linked0.75_temp, all.x=T, all.y=T) # Then merging to the original linked file
  }
}

## Cleanup environment as it can get busy:
rm(linked0.5_temp, linked0.75_temp)



 ###Lines to convert numbers above 0.5 into rsID strings
linked_test0.5 =linked0.5 # duplicate the new dataframe
# This is a little complicated to understand so do read the description above
for(n in 2:ncol(linked0.5)){
  linked_test0.5[,n] = with(linked_test0.5, ifelse(linked_test0.5[,n]>=0.5, linked_test0.5[,1], linked_test0.5[,n]))
}
head(linked_test0.5)

# now we set up a r2ictionary so we can see which snps associate with which snps
rs_overlap_r20.5 = vector(mode="list", length = nrow(YOUR_GENE_NAME_r2)) # set up a dictionary style list
names(rs_overlap_r20.5) = names(YOUR_GENE_NAME_r2[,2:ncol(YOUR_GENE_NAME_r2)]) # add in the names of the snps (rsids)

for(n in 1:(ncol(linked_test0.5)-1)){
  rs_overlap_r20.5[[n]] = na.omit(linked_test0.5[,n+1]) # fill in the associated snps from the matrix columns
}
test = na.omit(linked_test0.5[,1+1])


 ###Lines to convert numbers above 0.5 into rsID strings
linked_test0.75 =linked0.75 # duplicate the new dataframe
# This is a little complicated to understand so do read the description above
for(n in 2:ncol(linked0.75)){
  linked_test0.75[,n] = with(linked_test0.75, ifelse(linked_test0.75[,n]>=0.75, linked_test0.75[,1], linked_test0.75[,n]))
}

# now we set up a dictionary so we can see which snps associate with which snps
rs_overlap_r20.75 = vector(mode="list", length = nrow(YOUR_GENE_NAME_r2)) # set up a dictionary style list
names(rs_overlap_r20.75) = names(YOUR_GENE_NAME_r2[,2:ncol(YOUR_GENE_NAME_r2)]) # add in the names of the snps (rsids)

for(n in 1:(ncol(linked_test0.75)-1)){
  rs_overlap_r20.75[[n]] = na.omit(linked_test0.75[,n+1]) # fill in the associated snps from the matrix columns
}
test = na.omit(linked_test0.75[,1+1])

# Saving for later
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
#Cleanup before saving the data
rm(df, YOUR_GENE_NAME_r2, Gtex_YOUR_GENE_NAME, linked_test0.5, linked_test0.75, linked0.5, linked0.75, temp, temp0.5D_2, temp0.75D_2, unique_snps, i,n,test)
##Save the environment
save.image("rs_overlap_ALL_YOUR_GENE_NAME.RData")

}


# ### Step d) Merging with the merged dataset:
# The next step is to merge these changes with the dataset so we can filter out during plotting. This will be found in the merging section (Step 5)
# 
# ## 2.3 Cleaning out Linked SNPs using SNPclip SKIP IF 2.1 and 2.2 USED!
# If the number is over 1000 it is not possible to use LD links LDmatrix. Instead we have to filter out the linked snps early. This potentially misses some associated traits with a snp cluster but if you have over 1000 this should not be an issue.
# 
# go to https://ldlink.nci.nih.gov/?tab=snpclip for details
# 
# Run chunk below OR copy and paste your unique_snp_list into this setting your cutoff appropriately (cutoff by default is r2 = 0.1 and MAF = 0.01). 
# 
# I tend to just go with r2 cutoff = 0.5 but can be adjusted if you like. The exercise here is getting rid of inaccuracies from linked snps and reducing the list of unique snps down. As an example ORMDL3 one of my controls had ~1200 SNPs and an r2 of 0.5 took this down to 60 SNPs. When searched in Phewas this still resulted in 1000s of SNP-trait associations and so still gave a good picture on what was going on. 


if(length(unique_YOUR_GENE_NAME_Gtex_snps)>=1000){
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/LDMatrix")

 library(LDlinkR)
 YOUR_GENE_NAME_LIMITED_SNP_LIST = SNPclip(
   unique_YOUR_GENE_NAME_Gtex_snps,
   pop = "EUR",
   r2_threshold = "0.5",
   maf_threshold = "0.01",
  token = "f0d7bc798f5c" )


YOUR_GENE_NAME_LIMITED_SNP_LIST = YOUR_GENE_NAME_LIMITED_SNP_LIST[grep("Variant kept.", YOUR_GENE_NAME_LIMITED_SNP_LIST$Details),  ] # selects the ones that passed the test
YOUR_GENE_NAME_LIMITED_SNP_LIST = as.data.frame(YOUR_GENE_NAME_LIMITED_SNP_LIST[,1])
names(YOUR_GENE_NAME_LIMITED_SNP_LIST) = "rsid"

write_csv(YOUR_GENE_NAME_LIMITED_SNP_LIST, "YOUR_GENE_NAME_LIMITED_SNP_LIST.csv")
unique_YOUR_GENE_NAME_Gtex_snps = read_csv("YOUR_GENE_NAME_LIMITED_SNP_LIST.csv")# , col_names=F
unique_YOUR_GENE_NAME_Gtex_snps = unique_YOUR_GENE_NAME_Gtex_snps$rsid
}
```


It may take a couple of iterations but essentially be as harsh or as leniant as you like here, you can always come back and adjust (running the whole script again) if the results are too limited.

save this list as YOUR_GENE_NAME_LIMITED_SNP_LIST.csv in YOUR_GENE_NAME_test/Gtex

# STEP 2: PheWAS searching using ieugwasr 
## Searching snps in ieugwasr (source code: Phewas testing.R)
This next step isn't automatable within the knitr - html format so it is all commented out. To run, use Rstudio.

Then we search using that list in ieugwasr. NOTE:  Large lists of rsIDs can cause a timeout in the search. Give it a go as is and if it doesn't work, then split into batches INCOMPLETE: HASN'T FAILED TO WORK FOR ME YET SO THIS - so unsure on batch size.

NOTE: this chunk of code is your search tool which is why it can't be run with the notebook, uncomment (ctrl-shift-c) and run line by line by clinking on the line and ctrl-enter. Uncommenting then running this chunk may work but often doesn't so line-by-line is safest.
IMPORTANT: Here I have left it as the unique_YOUR_GENE_NAME_gtex_snps (unique snp list) but you can also use your LIMITED_snp_list (YOUR_GENE_NAME_LIMITED_SNP_LIST) from step 2.3 IF YOU USED IT. 

### Load in appropriate dataframe and setup a list of unique SNPs, if 2.1 and 2.2 ran:

searching IEU PheWAS database
Sometimes this works sometimes it doesn't try pressing play and if not:
RUN THIS CHUNK LINE BY LINE,  click the start of the line at pres ctrl-enter or command-enter for mac
```{r,Phewas searching must run line by line using ctrl-enter}
# Load in package - should have been done at start
library(ieugwasr)

# change out list of snps from unique_YOUR_GENE_NAME_Gtex_snps to LIMITED_SNP_LIST here depending on choice above
 Gtex_PHEWAS = phewas(unique_YOUR_GENE_NAME_Gtex_snps, pval = 1e-04) # Adjustable p-value here #

if(nrow(Gtex_PHEWAS)==0){
  print("Houston, we have a problem. Re run this chunk using the play button in the top right of the box. If that still doesn't work, run line by line using ctrl-enter OR cmd-enter. If it still doesn't work then I'm afraid something has gone really wrong! email me at hy14913@bristol.ac.uk")
} else{
# Then save using the following line:
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_excel_csv(Gtex_PHEWAS, "YOUR_GENE_NAME_GtextoPHEWAS_RAW.csv")
}
```
The result of this is seen below with head(YOUR_GENE_NAME_GtextoPHEWAS_RAW).

# Step 3: Merging the datasets

## For Gtex: (source code: Gtex-PSandPHEWAS_merger.R)

Merging was fairly riddled with pitfalls. In the end the dyplr(full_join) (also part of the tidyverse) worked out a treat.

Firstly, load in these libraries and start to reorganize the Gtex-to-phewas RAW and original Gtex data to get more of a feel for what the data looks like:
```{r initial read in of dataframes and ordering step}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
YOUR_GENE_NAME_GtextoPHEWAS_RAW = read_csv("YOUR_GENE_NAME_GtextoPHEWAS_RAW.csv") # load in Phewas output
YOUR_GENE_NAME_Gtex_cleaned = read_csv("YOUR_GENE_NAME_Gtex_cleaned.csv") #  load in Gtex input

YOUR_GENE_NAME_GtextoPHEWAS_RAW = YOUR_GENE_NAME_GtextoPHEWAS_RAW %>%
  rename(position_phewas = position, # Renaming columns to keep track of their original dataframe
         chr_phewas = chr)




#####Reordering PheWas and Gtex dataset - extra - to be removed #####
# NOT NECERSARY BUT MAKES IT EASIER TO LOOK AT !

 YOUR_GENE_NAME_Gtex_cleaned = YOUR_GENE_NAME_Gtex_cleaned[,c( "Gencode Id","Gene Symbol","rsid","a","b", "NES","|NES|","Tissue", "P-Value", "Variant Id","chr_gtex", "position_gtex", "build_gtex")]
 head(YOUR_GENE_NAME_Gtex_cleaned)
 YOUR_GENE_NAME_GtextoPHEWAS_RAW = YOUR_GENE_NAME_GtextoPHEWAS_RAW[,c("rsid", "ea","nea","trait","beta", "p","se","n","eaf","chr_phewas","position_phewas", "id")] # "traitgroup",
 head(YOUR_GENE_NAME_GtextoPHEWAS_RAW)
```

Next step is to actually merge these two dataframes: Either of these work, I use merge because I found it first, but since I've been using dyplr this full_join is also nice. Worth checking that both produce the same dataframe as a test!

```{r Merging the gtex and phewas dataframes}

test = merge(YOUR_GENE_NAME_Gtex_cleaned, YOUR_GENE_NAME_GtextoPHEWAS_RAW, all=T, by = "rsid")
# OR
test2 = full_join(YOUR_GENE_NAME_Gtex_cleaned, YOUR_GENE_NAME_GtextoPHEWAS_RAW, by = "rsid")
# You will lose eQTL type but that's fine, old column when i was tempted by doing sQTLs too
test = test[,c("Gencode Id","Gene Symbol","rsid","a","b", "NES","|NES|","Tissue", "P-Value", "Variant Id","chr_gtex", "position_gtex", "build_gtex", "ea","nea","trait","beta", "p","se","n","eaf","chr_phewas","position_phewas", "id")]

head(test) 
head(test2)

```
The next step is cleaning up the merge and checking that it has worked as expected:
NOTE: the positions WILL NOT MATCH. phewas uses build 37 where gtex uses b38 so just be aware of this

There'll be some rows where it only has Gtex data, i.e. rsids that didn't come out with a result from PHEWAS searching.
To clean this, remove rows where there are NA's for multiple columns in PHEWAS section:

```{r cleaning up the merge step}


# test number of rows with NAs to see the issue:
test$na_count = apply(test, 1, function(x) sum(is.na(x)))
to_remove = test[which(test$na_count>5),]
head(to_remove) # any rows with lots of NAs in Phewas columns

## Remove rows with NA in these PHEWAS columns
test = test %>% drop_na(beta, eaf, chr_phewas, trait) 

## here a couple of testing lines to see a specific rsidif you want to check your merge worked ok
# test_rsid = PS_YOUR_GENE_NAME[which(PS_YOUR_GENE_NAME$rsid =="rs78616393"),]
# test_rsid = Gtex_YOUR_GENE_NAME[which(Gtex_YOUR_GENE_NAME$rsid =="rs78616393"),]

rm(test2) # cleanup removing the extra table 

  
#setwd("~/OneDrive - University of Bristol/PhD/Epidemiology/Cross-Reference/GtextoPheWAS-Sorted/YOUR_GENE_NAME")
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_excel_csv(test, "YOUR_GENE_NAME_merge_GTEX_PHEWAS.csv")




```
## Correcting beta, ambiguous cases and adding groups: (source code: Trait-tissue_list_gather_for_comparison.R)

Now that we have a merged table, we now need to filter out any ambiguous cases. These include A-T or C-G mutations as well as checking that the reference and effect alleles match for phewas/gtex and correcting the beta value if not.
### 3a. beta:
Firstly, Let's correct the beta value (this can be done later if you forget) :
```{r setting up a corrected beta column}
# Setup df as our merged dataframe:
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
df = read_csv("YOUR_GENE_NAME_merge_GTEX_PHEWAS.csv")
#Sometimes the alleles slip into TRUE/FALSE collumns so to correct that:
df$a = as.character(df$a)
df$b= as.character(df$b)
df$ea= as.character(df$ea)
df$nea = as.character(df$nea)


df$beta_cor = ifelse(df$ea == df$b & df$nea == df$a, df$beta,
                     ifelse(df$ea == df$a & df$nea == df$b, df$beta*-1, NA))



if ((sum(is.na(df$beta_cor)) == 0)==TRUE){
  print("There are no mutations that share an rsid that are completely different in Gtex and PheWAS")
} # if true then all good, if not you need to remove these cases as they are completely different.

df=df[which(is.na(df$beta_cor)==F),] # Removing cases where alleles are completely different - they are rare and just add confusion



write_excel_csv(df, "YOUR_GENE_NAME_merge_GTEX_PHEWAS-betacor.csv")
```

### 3b. ambiguous cases (AT  CG):
To solve reverse vs sense strand issues
```{r setting up an ambiguous case column}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
df = read_csv("YOUR_GENE_NAME_merge_GTEX_PHEWAS-betacor.csv")




df$AT = ifelse(df$ea == "A" & df$nea == "T", "Yes", 
             ifelse(df$ea == "T" & df$nea == "A", "Yes",
                    ifelse(nchar(df$ea) != nchar(df$nea), "FS", "No")))

df$GC = ifelse(df$ea == "G" & df$nea == "C", "Yes", 
             ifelse(df$ea == "C" & df$nea == "G", "Yes",
                    ifelse(nchar(df$ea) != nchar(df$nea), "FS", "No")))


df$ambiguous = ifelse(df$AT =="Yes","AT/TA",
                     ifelse(df$GC =="Yes","GC/CG",
                            ifelse(df$GC =="FS" | df$AT=="FS", "FS", "No")))



number_of_ambiguous_cases = df[which(df$ambiguous != "No"),]


paste0("The percentage of ambiguous cases is ",nrow(number_of_ambiguous_cases)/nrow(df)*100,"%")  # Gives % of cases in df which are ambiguous.

head(df)

#setwd("~/OneDrive - University of Bristol/PhD/Epidemiology/Cross-Reference/GtextoPheWAS-Sorted/YOUR_GENE_NAME")
write_excel_csv(df, "YOUR_GENE_NAME_merge_GTEX_PHEWAS_betacor_ambig.csv")

```
For the moment we are just labelling the ambiguous data, we can filter it out when plotting.

There is also the possibility that you might have an A-G mutant in Gtex and then find that the phewas is T-C. This might be due to a how the snp was found (reverse strand error), however, if that were the case we would pick it up in the beta_cor section as NA because the bases are 'completely different' So far, this hasn't happened but it is important to keep an eye out for and remove and beta_cor NA rows if needed.

The next step is to group the tissues and traits

### 3c-1. Trait grouping
I have gone through and categorised all the traits in the trait tabel from the open IEUOPENGWAS project. Sometimes there may be some minor case issues which you'll ahve to sort by hand (or as new studies are added to the database). I will make it available as both the original version that I've done and as a community modifyable version so we can keep it updated together!

We need to assign those groups to the main dataframe:

```{r Assign Trait Groups}
# read in our df (traits vs SNPs)
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
df = read_csv( "YOUR_GENE_NAME_merge_GTEX_PHEWAS_betacor_ambig.csv")
# read in trait database
setwd("C:/Users/Harry Young/Documents/Local Wokr/Trait and Tissue Groups")
Full_trait_database = read_csv("Full_trait_database.csv")
#loop to assign these groups
df_backup=df
# df$traitgroup = df$trait
# for( n in 1:nrow(df)){ ## same again with traits this time - UPDATE TRAIT LISTS BEFORE STARTING
#   for( i in 1:nrow(Full_trait_database)){
#     if(df$traitgroup[n]==Full_trait_database$Traits[i]){
#       df$traitgroup[n] = Full_trait_database$Group[i]
#     }
#   }
# }
# head(df)

#NEW VERSION - in TESTING MARCH 2021

df = left_join(x=df_backup, y=Full_trait_database) # NEW VERSION

if(sum(is.na(df$traitgroup))==0){
  print("Merge succesful, no NA's")
} else{
  paste(df$trait[which(is.na(df$traitgroup)==T)], "needs to be added to Full_trait_database")
}


```


### 3c-2. Now for the Tissues:

This time the database won't change because Gtex has a finite number of tissues. Therefore open up Epidemiology/Trait and Tissue Groups/Full_tissue_database.csv:

```{r Assign Tissue Groups}
# load in tissue database
setwd("C:/Users/Harry Young/Documents/Local Wokr/Trait and Tissue Groups")
Full_tissue_database = read_csv("Full_tissue_database.csv")

# df$tissue_group = df$Tissue ## duplicate the search column
# df$tissue_group_secondary = "NA"
# 
# for( n in 1:nrow(df)){# goes through each tissue group and binds these to the original data set
#   for( i in 1:nrow(Full_tissue_database)){
#     if(df$tissue_group[n] == Full_tissue_database$RAW_Tissue[i]){
#       df$tissue_group[n] =  Full_tissue_database$Tissue[i]
#       df$tissue_group_secondary[n] =  Full_tissue_database$Secondary[i]
#     }
#   }
# }
# 
# head(df)

#NEW VERSION - IN TESTING March 2021
df_backup = df

Full_tissue_database = Full_tissue_database %>%
  rename(tissue_group = Tissue,
         Tissue=RAW_Tissue,
         tissue_group_secondary = Secondary)

df = left_join(x=df_backup, y=Full_tissue_database) # NEW VERSION

 
```

Next it's going to be useful to have a simple binary column for positive and negative NES and beta values
```{r adding in binary NES and beta direction columns}


df$beta_direction = ifelse(df$beta_cor<0, "Negative",
							ifelse(df$beta_cor>0, "Positive", "No Change"))

df$NES_direction = ifelse(df$NES <0, "Negative",
							ifelse(df$NES>0, "Positive", "No Change"))
# save unorganised
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_excel_csv(df, "YOUR_GENE_NAME_merge_GTEX_PHEWAS_betacor_ambig_grouped.csv")
```


### Reorganise for ease of looking at it
OK, final step is to reorganise this and spend a little time looking through the data making sure it all looks as expected. 

```{r Save Merged Dataset}
#reset wd to test folder


df = df[,c("Gene Symbol",
           "rsid",
           "a",
           "b",
           "NES",
           "|NES|",
           "Tissue",
           "tissue_group",
           "tissue_group_secondary",
           "P-Value",
           "ea",
           "nea",
           "trait",
           "traitgroup",
           "Subcat",
           "Alt_Subcat",
           "beta_cor",
           "beta" , 
           "AT",
           "GC",
           "ambiguous",
           "p",
           "se",
           "n",
           "eaf",
           "chr_phewas",
           "position_phewas",
           "id",
           "Variant Id",
           "chr_gtex",
           "position_gtex",
           "build_gtex",
           "Gencode Id",
           "na_count",
           "beta_direction",
           "NES_direction")]
            #"LD_D_0.75", # remove these last 4 lines if you skipped the last chunk
           # "LD_D_0.5",
            #"LD_r2_0.75",
           # "LD_r2_0.5")] 

# setwd("~/OneDrive - University of Bristol/PhD/Epidemiology/Cross-Reference/GtextoPheWAS-Sorted/YOUR_GENE_NAME")
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_excel_csv(df, "YOUR_GENE_NAME_merge_GTEX_PHEWAS_betacor_ambig_grouped.csv")
```

OK, looking good, we now have our new dataset, merged with the added columns for traitgroup and tissue group.


### 3d. More Data Cleaning
Firstly you need to clean up 'repeated traits'. This is annoying things like a comma in one name:

    e.g Forced vital capacity (FVC), Best measure" and "Forced vital capacity (FVC)  Best     measure"

These 2 appear as separate traits where they are essentially the same. So the following lines helps clean this up. I tend to look at the plots then come back to this code to add in more errors. But this serves as a list of ones I've found!

```{r Cleaning up duplicated traits}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
df = read_csv("YOUR_GENE_NAME_merge_GTEX_PHEWAS_betacor_ambig_grouped.csv")

# all of these work as replace the first argument with the second argument
df = df %>% 
  mutate(trait = ifelse(as.character(trait) == "Serum creatinine (eGFRcrea)", "Serum creatinine", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Heel bone mineral density (BMD) T-score, automated", "Heel bone mineral density (BMD) T-score automated",  as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) == "COPD/asthma/ILD related pneumonia or pneumonia derived septichaemia", "COPD/asthma related pneumonia or pneumonia derived septichaemia",  as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Estimated glomerular filtration rate (eGFR)", "Estimated glomerular filtration rate", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Forced expiratory volume in 1-second (FEV1), Best measure", "Forced expiratory volume in 1-second (FEV1)  Best measure", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Forced vital capacity (FVC), Best measure", "Forced vital capacity (FVC)  Best measure", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Heel bone mineral density", "Heel bone mineral density (BMD)", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Heel bone mineral density (BMD), T-score  automated", "Heel bone mineral density (BMD) T-score  automated", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Body mass index (BMI)", "Body mass index", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Apoliprotein B", "Apolipoprotein B", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "Apoliprotein A", "Apolipoprotein A", as.character(trait))) %>%
 mutate(trait = ifelse(as.character(trait) == "Forced expiratory volume in 1-second (FEV1), predicted percentage Respiratory Function","Forced expiratory volume in 1-second (FEV1)  predicted percentage Respiratory Function",  as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) =="Diastolic blood pressure  automated reading", "Diastolic blood pressure, automated reading", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) =="Systolic blood pressure  automated reading",  "Systolic blood pressure, automated reading", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) =="Blood clot  DVT  bronchitis  emphysema  asthma  rhinitis  eczema  allergy diagnosed by doctor: Emphysema/chronic bronchitis",  "Blood clot, DVT, bronchitis, emphysema, asthma, rhinitis, eczema, allergy diagnosed by doctor: Emphysema/chronic bronchitis", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) == "bipolar disorder", "Bipolar disorder", as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) == "white blood cell count", "White blood cell count", as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) == "Neutrophill", "Neutrophil", as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) == "Mean corpuscular haemoglobin", "Mean corpuscular hemoglobin", as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) == "Haemoglobin concentration", "Hemoglobin concentration", as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) == "Low−density−lipoprotein cholesterol", "LDL cholesterol", as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) == "Neutrophill", "Neutrophil", as.character(trait))) %>%
  mutate(trait = ifelse(as.character(trait) == "Plateletcrit", "Platelet crit", as.character(trait))) %>% 
  mutate(trait = ifelse(as.character(trait) == "systolic blood pressure", "Systolic blood pressure", as.character(trait)))%>%
  mutate(trait = ifelse(as.character(trait) =="colorectal cancer",  "Colorectal Cancer", as.character(trait)))%>%
    mutate(trait = ifelse(as.character(trait) =="Crohn disease",  "Crohn's disease", as.character(trait)))%>%
    mutate(trait = ifelse(as.character(trait) =="Diagnoses - main ICD10: M70 Soft tissue disorders related to use, overuse and pressure",  "Diagnoses - main ICD10: M70 Soft tissue disorders related to use  overuse and pressure", as.character(trait)))%>%
      mutate(trait = ifelse(as.character(trait) =="diastolic blood pressure",  "Diastolic blood pressure", as.character(trait)))%>%
        mutate(trait = ifelse(as.character(trait) =="Diastolic blood pressure, automated reading",  "Diastolic blood pressure  automated reading", as.character(trait)))
  


#Follistatin
#follistatin
#Indolelactate
#Indolelacetate
#Forced expiratory volume in 1-second (FEV1)  predicted
#Forced expiratory volume in 1-second (FEV1)  predicted percentage

#Forced expiratory volume in 1-second (FEV1), predicted
#Forced expiratory volume in 1-second (FEV1), predicted percentage
# Multiple sclerosis
# multiple sclerosis
#myeloperoxidase
#Myeloperoxidase

#Obsessive Compulsive Disorder
#Obsessive-compulsive disorder

#P-Selectin
#P-selectin

#Prolactin
#prolactin
#Prolactin Receptor
#Prolactin receptor

#renin
#Renin

#resistin
#Resistin

#spondin 1
#Spondin-1

#Subjective well being
#Subjective well-being
# Loneliness  isolation
# Loneliness, isolation
# Long-standing illness  disability or infirmity
# Long-standing illness, disability or infirmity
# Major Depressive Disorder
# Major depressive disorder


FVC_test = df[which(df$trait =="Forced vital capacity (FVC)  Best measure"),]
FVC_test2 = df[which(df$trait =="Forced vital capacity (FVC), Best measure"),]
FVC_orginal = df[which(df$trait =="Forced vital capacity (FVC)  Best measure" |df$trait =="Forced vital capacity (FVC), Best measure"),]

head(FVC_test)

head(FVC_test2)

if(nrow(FVC_test2) == 0 & nrow(FVC_test) == nrow(FVC_orginal)){
  print("Correction for FVC worked!")
}

```

FVC_test2 should be empty and FVC_test  should have the same number of rows as FVC_original. You can modify these to include whichever one you want to test has worked OK. - ALTER THE if statement at the end of the chunk


# Step 4: LD removal and final cleanup


Also, you need rs_overlap_D0.5/0.75 and rs_verlap_R0.5/0.75 in your environment from step b of the LDMatrix steps or this won't work.

This is the second half to the disregarded box before. Nice to have all the data in one place but I don't think it is worth it. I've moved it to "Archive - LDMATRIX MERGE" in case you want to use it but I will skip over it now.

The next 4 steps filter out all of the data we don't want:

###4a. ukb-a is superfluous:
```{r Select and remove ukb-a}
df = df[grep("ukb-a", df$id, invert = TRUE), ]

```
###4b. Next, we need to check that ukb-d and ukb-a aren't simply repeating each other in terms of a snps effect on a trait in most cases:
```{r test ukb-d/a overlap}
ukb_b = df[grep("ukb-b-", df$id),] #Select only these data
ukb_d = df[grep("ukb-d-", df$id),]
ukb_b = ukb_b[,c("rsid", "trait")]
ukb_d = ukb_d[,c("rsid", "trait")]#simplify to rsid and trait

test = inner_join(ukb_b,ukb_d)
nrow(test)
if(nrow(test)==0){
  print("There is no overlap between UKb-b and -d")
}
if(nrow(test)>0){
  print("There is overlap between UKb-b and -d, assess whether to remove or not!")
}
```
if nrow(test) is 0 then no overlap, if not you need to check what overlap there is and if it's problematic. (That may be ambiguous but you probably want to just filter out any duplicated results in this case. But that may not always be true so you've got to make that judgement call)

###4c-2 - (3a). Ambiguous case removal: (may seem out of place but like LD, this was assessed earlier and not removed until now)
```{r Removal of any abiguous cases}
df = df[which(df$ambiguous == "No" | df$ambiguous == "FS"),]

#And finally save it:
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_csv(df, "YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL.csv")
```
###4d. Ok now to deal with those pesky LD snps  - SKIP IF YOU RAN 2.3 - it will error anyway if you try

This is a little more complicated to filter out retrospectively. Arguably I should have filtered out the linked snps prior to the search. The issue with this is that you may miss some associations. For example, if rs1 - kidney disease and rs1 is linked to rs 2 and rs 3, then we choose only to search rs3. rs3 isn't associated with anything so we miss the effect of a snp by filtering prior to the search.

It makes our lives harder here but hopefully it's worth it to have a better indication of snps' effect on disease.

The plan is as follows:
    
    Sort by p-value (phewas) from smallest to largest (most sig to least sig)
    For every unique rsid-trait combo,
    split the list of linked snps (LD0.75 or LD0.5) into a searchable string
    search the dataframe for each linked_rsid,
    if a linked_rsid is paired with the same trait as the original rsid-trait combo,
    Then keep only the highest p-value row.
BACKUP LOOP IN ARCHIVE

```{r Removal of LD linked snps for r20.5}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
unique_YOUR_GENE_NAME_Gtex_snps= read_tsv("unique_YOUR_GENE_NAME_Gtex_snps.csv", col_names = FALSE) # read the original unique snps file
unique_YOUR_GENE_NAME_Gtex_snps = unique_YOUR_GENE_NAME_Gtex_snps$X1
if(length(unique_YOUR_GENE_NAME_Gtex_snps)<700){
rm(list=ls())
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
load("rs_overlap_ALL_YOUR_GENE_NAME.RData")  # specifically the dataframe with ambiguous data removed
## Annoyingly, in testing this stuff I found another source of error in my code. There are a whole load of snps that have been associated with a trait twice with similar p-values - I think these are OK because essentially they have been shown by two separate studies.

df = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL.csv")
backup =df

dfneg=backup[which(backup$beta_direction=="Negative"),]
backupneg=dfneg
dfneg = dplyr::select(dfneg, rsid, p, trait,beta_direction) # selects key columns for assigning linkage
dfneg= unique(dfneg) # remove all replicates created with tissue merge
dfneg$test ="unlinked"
# Sort by p-value (phewas) from smallest to largest (most sig to least sig)
arrange(dfneg, p)
# unique rsid-trait combos 
rsid_trait_combos_neg = subset(dfneg, select = c(rsid, trait)) #simplify to two columns
rsid_trait_combos_neg = unique(rsid_trait_combos_neg) # pull out unique values

dfpos=backup[which(backup$beta_direction=="Positive"),]
backuppos=dfpos
dfpos = dplyr::select(dfpos, rsid, p, trait,beta_direction) # selects key columns for assigning linkage
dfpos= unique(dfpos) # remove all replicates created with tissue merge
dfpos$test ="unlinked"
# Sort by p-value (phewas) from smallest to largest (most sig to least sig)
arrange(dfpos, p)
# unique rsid-trait combos 
rsid_trait_combos_pos = subset(dfpos, select = c(rsid, trait)) #simplify to two columns
rsid_trait_combos_pos = unique(rsid_trait_combos_pos) # pull out unique values

for(n in 1:nrow(rsid_trait_combos_neg)){
  
  test_id = rsid_trait_combos_neg$rsid[n]
  test_trait = rsid_trait_combos_neg$trait[n]
  for(i in 1:length(rs_overlap_r20.5[[rsid_trait_combos_neg$rsid[n]]])){
    
    if(length(rs_overlap_r20.5[[rsid_trait_combos_neg$rsid[n]]])>1){ # if there is more than 1 linked_snp
      
      linked_id = rs_overlap_r20.5[[rsid_trait_combos_neg$rsid[n]]][i]# selects every rsid linked with the nth rsid 
      if(linked_id != test_id){# if the test and linked are not the same
        ##### If there is exactly one test rsid row#######
        if(nrow(dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),])==1){
          
          if(dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),]["test"]=="unlinked"& # has it been previously linked
             
             nrow(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),])>0){ # checking there are some linked_snps - nrow is not 0
            ##### If there is exactly one linked_rsid row######
            if(nrow(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),])==1){
              
             
              if(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),]["p"] >=
                    dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),]["p"]){ # If the linked_id-p value is higher/equal to, then mark it to be removed
                  
                dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),]["test"]="linked"# select all rows in dfneg that the linked snp and the test _trait is in, label linked
                }
              else{# else mark the test_id it to be removed
                  dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),]["test"]="linked"
                }
          }
            ##### if there is more than one linked_rsid low#########
              else if(nrow(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),])>1){
                  
                minpl = min(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait ),]["p"])
                if(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait & dfneg$p == minpl),]["p"] >=
                      dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),]["p"]){
                    
                  dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),]["test"]="linked"# select all rows in dfneg that the linked snp and the test _trait is in, label linked
                  }
                else{
                    dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),]["test"]="linked"
                  }
            }
          }
        }
        ##### If there is more than one test rsid row#####
        else if(nrow(dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),])>1){
          
          minpt = min(dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait ),]["p"])
            if(dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait & dfneg$p == minpt),]["test"]=="unlinked"& # has it been previously linked
                nrow(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),])>0){
              #### if there is exactly one linked_rsid row####
              if(nrow(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),])==1){
                
                if(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),]["p"] >=
                    dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait & dfneg$p == minpt),]["p"]){
                  
                dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),]["test"]="linked"# select all rows in dfneg that the linked snp and the test _trait is in, label linked
                  }
                else{
                  dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),]["test"]="linked"
                  }
              }
              ####else if there is more than one linked_rsid row
              else if(nrow(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),])>1){
                
                minpl = min(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait ),]["p"])
                if(dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait & dfneg$p == minpl),]["p"] >=
                    dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait& dfneg$p == minpt),]["p"]){
                  
                dfneg[which(dfneg$rsid == linked_id & dfneg$trait == test_trait),]["test"]="linked"
                  }
                else{
                  dfneg[which(dfneg$rsid == test_id & dfneg$trait == test_trait),]["test"]="linked"
                  }
              }
          }
        }
      }
    }
  }
}

test2neg = full_join(dfneg, backupneg, by = c("rsid","p","trait")) # merging back with the original table


testneg = test2neg[which(test2neg$test=="unlinked"),]



#these two test lines check whether a small sample have worked
# rs72940739 = df[which(df$rsid =="rs72940739"),]
# rs17640713 = df[which(df$rsid =="rs17640713"),]
# #rs10172305 = df[which(df$rsid =="rs10172305"),]
# rs_overlap_D0.5[["rs6433675"]]
# testing = full_join(rs72940739,rs17640713) # For every pair, the smallest should be unlinkeD!
# head(testing)
# ## Extra testing lines if needed
# # df[which(df$trait =="HDL cholesterol"),]
# # 
# # backup[which(backup$trait =="HDL cholesterol"),]

## Now for ukd ambiguity:

# nrow(df[which(df$id =="ukb-d-30830_raw"),]) ==nrow(df[which(df$id =="ukb-d-30830_irnt"),])
# test = anti_join(df[which(df$id =="ukb-d-30830_raw"),],df[which(df$id =="ukb-d-30830_irnt"),])

## testing out whether it is doing exactly what I want it to do 

# test2= df[which(df$traitgroup=="Respiratory Function"),]
# testNEG=test2[which(test2$beta_direction=="Negative"),]
# testrs139423036=test2[which(test2$rsid=="rs139423036"),]
# testrs10172305=test2[which(test2$rsid=="rs10172305"),]


### NOW FOR POS

for(n in 1:nrow(rsid_trait_combos_pos)){
  
  test_id = rsid_trait_combos_pos$rsid[n]
  test_trait = rsid_trait_combos_pos$trait[n]
  for(i in 1:length(rs_overlap_r20.5[[rsid_trait_combos_pos$rsid[n]]])){
    
    if(length(rs_overlap_r20.5[[rsid_trait_combos_pos$rsid[n]]])>1){ # if there is more than 1 linked_snp
      
      linked_id = rs_overlap_r20.5[[rsid_trait_combos_pos$rsid[n]]][i]# selects every rsid linked with the nth rsid 
      if(linked_id != test_id){# if the test and linked are not the same
        ##### If there is exactly one test rsid row#######
        if(nrow(dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),])==1){
          
          if(dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),]["test"]=="unlinked"& # has it been previously linked
             
             nrow(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),])>0){ # checking there are some linked_snps - nrow is not 0
            ##### If there is exactly one linked_rsid row######
            if(nrow(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),])==1){
                
              if(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),]["p"] >=
                    dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),]["p"]){ # If the linked_id-p value is higher/equal to, then mark it to be removed
                  
                dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),]["test"]="linked"# select all rows in dfpos that the linked snp and the test _trait is in, label linked
                }
              else{# else mark the test_id it to be removed
                  dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),]["test"]="linked"
                }
          }
            ##### if there is more than one linked_rsid low#########
              else if(nrow(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),])>1){
                  
                minpl = min(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait ),]["p"])
                if(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait & dfpos$p == minpl),]["p"] >=
                      dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),]["p"]){
                    
                  dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),]["test"]="linked"# select all rows in dfpos that the linked snp and the test _trait is in, label linked
                  }
                else{
                    dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),]["test"]="linked"
                  }
            }
          }
        }
        ##### If there is more than one test rsid row#####
        else if(nrow(dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),])>1){
          
          minpt = min(dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait ),]["p"])
            if(dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait & dfpos$p == minpt),]["test"]=="unlinked"& # has it been previously linked
                nrow(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),])>0){
              #### if there is exactly one linked_rsid row####
              if(nrow(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),])==1){
                
                if(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),]["p"] >
                    dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait & dfpos$p == minpt),]["p"]){
                  
                dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),]["test"]="linked"# select all rows in dfpos that the linked snp and the test _trait is in, label linked
                  }
                else{
                  dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),]["test"]="linked"
                  }
              }
              ####else if there is more than one linked_rsid row
              else if(nrow(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),])>1){
                
                minpl = min(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait ),]["p"])
                if(dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait & dfpos$p == minpl),]["p"] >=
                    dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait& dfpos$p == minpt),]["p"]){
                  
                dfpos[which(dfpos$rsid == linked_id & dfpos$trait == test_trait),]["test"]="linked"
                  }
                else{
                  dfpos[which(dfpos$rsid == test_id & dfpos$trait == test_trait),]["test"]="linked"
                  }
              }
          }
        }
      }
    }
  }
}

test2pos = full_join(dfpos, backuppos, by = c("rsid","p","trait"))
# Saving it 
test2=rbind(test2neg,test2pos)
test2 = test2 %>% rename(beta_direction = beta_direction.y)
test2 = test2 %>% dplyr::select(-c("beta_direction.x"))
write_csv(test2, "YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_linkagetempr20.5.csv")# full dataframe but with the "test" column 

## OK now we've done that we can look at this ukb-d-raw vs irnt discrepancy


test = test2[which(test2$test=="unlinked"),]


write_csv(test, "YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv") # reduced df
} else{
  df = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL.csv")
  df$test ="filler"
  write_csv(df, "YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")
}

```

# Step 5: Plotting the data so far (source code: Trait-tissue_comparer_MAIN_PLOTTING_SCRIPT.R):
This section is a little less rigid and I would encourage you to think about what kind of things we might be able to pull from the dataset.

However, I think a good starting point is to plot the data of p-value vs trait; Faceted to be split by direction of expression change (NES) and trait group; and colour coded based on the direction of the beta value.
## Now for the actual plotting:
NOTE: I'm not going to go line by line for the ggplotting functions in all of the code below as it's all explained very nicely in the gg cheatsheet available online. 

You will need to activate library(ggplot2() and library(ggpubr) in the console (or install if you don't have them).

For this section I also have made new file directories for each subheading of plots for easier browsing later. However, I have left these out of the code so you can just click through without the complicated sub-folder system. 

Finally, it also occurs to me you may want the exact set of plots I have used in the example data. SO here is a list of the file name of each of those plots. Run it all and then you can just search your file directory accordingly:

Main results Figure:
(A) Not in script, downloaded direct from Gtex website
(B) TissueGROUP-rsid_count_OVERVIEW 
(C) RNAvsMERGEDdfcount
(D) Position_count_OVERVIEW
(E) pvalvstraitgroup_LOG
(E') pvsTrait_INFL_LOG_TISCOL
(E'') pvsTrait_BODY_LOG_TISCOL
(F) COUNTvstraitgroup_REL_overview_SEATLE#

Circos Figure:
Position_Gtex_P
Tissue_trait_overlap
trait_position
+ curved gene diagrams:
Curved_gene_diagram_P_FULL_Colour
Curved_gene_diagram_RED_colour




## Gtex Overview data - what tissues have what number of reads - from FULL gtex data from website - SKIPPABLE

Before we get started on the data we've so lovingly brought to this stage, it is important to consider the distribution of the Gtex data. By looking at the number of samples and number of eGenes (Genes that are deferentially expressed between donors) per tissue it gives us a baseline to compare to. For example, if one tissue (e.g. skin or testis) has vastly more samples or eGenes than another tissue, then more SNPs and SNP-trait associations in this tissue can be expected. Grab this data from https://www.gtexportal.org/home/tissueSummaryPage -v8 sample info as table. copied then saved as a csv : "sample-egene_info_Gtex.csv".

```{r Loading in and sorting out raw Gtex data and assigning Tissue Groups}





setwd("C:/Users/Harry Young/Documents/Local Wokr/eGene")
#load in full egene info from gtex
Gtex_egene = read_csv("sample-egene_info_Gtex.csv")
# and full_tissue_database
Full_tissue_database = read_csv("Full_tissue_database.csv") 
names(Full_tissue_database) = c("Tissue", "tissue_group", "tissue_group_secondary")
Gtex_egene = left_join(Gtex_egene, Full_tissue_database)



#Clean up columns - egenes and sgenes as character because of NULL
Gtex_egene$`# eGenes` = as.numeric(Gtex_egene$`# eGenes`) # sets as numeric and auto converts non numerics (in this case "null") into NA
Gtex_egene$`# sGenes` = as.numeric(Gtex_egene$`# sGenes`)

write_csv(Gtex_egene, "FINAL_Gtex_egene.csv")

head(Gtex_egene)
Gtex_egene$group_count_sum = 0
Gtex_egene$group_count_mean = 0
Gtex_egene$group_count_sd = 0

## setting up a new dataframe of count, mean and sd of the egene numbers
group_count_df_final = Gtex_egene %>% dplyr::select(tissue_group, group_count_sum, group_count_mean, group_count_sd)
group_count_df_final = unique(group_count_df_final)
for(group in Gtex_egene$tissue_group){ 
  test = Gtex_egene[which(Gtex_egene$tissue_group ==group),]
  test$group_count_sum = sum(test$`# eGenes`)
  test$group_count_mean = mean(test$`# eGenes`)
  test$group_count_sd = sd(test$`# eGenes`)
  group_count_df = test %>% dplyr::select(tissue_group, group_count_sum, group_count_mean, group_count_sd)
  group_count_df= unique(group_count_df)
  group_count_df_final = rbind(group_count_df, group_count_df_final)
  
  
}

group_count_df_final= unique(group_count_df_final)
group_count_df_final = group_count_df_final %>% filter_at(vars(group_count_sum, group_count_mean, group_count_sd), any_vars(. >0 | is.na(.)==TRUE)) 
setwd("C:/Users/Harry Young/Documents/Local Wokr/eGene")
write_excel_csv(group_count_df_final, "Gtex_egene_SUMMARY_CountsvsTissueGroup.csv")

```








Now lets plot it
```{r Plotting the raw Gtex egene data against Tissue}



Gtex_egenes_plot_full = ggplot(Gtex_egene, aes(x=Tissue, y=`# eGenes`, color = `# RNASeq and Genotyped samples`,fill = `# RNASeq and Genotyped samples`)) + #Plot of SNPs NES vs beta from original dataset
  #geom_jitter(aes(color=NES)) +
  geom_col()+ 
  scale_colour_viridis_c(direction=-1) + # colourblind friendly palette
  scale_fill_viridis_c(direction=-1) +
  labs(title= "Number of eGenes per Tissue", x= "Tissue", y= "Number of eGenes")+ # Labels
  geom_hline(aes(yintercept=0,))+ #  0 line
  theme(axis.text.x = element_text(angle = 70, hjust =1))  # text adjust

Gtex_egenes_plot_full



setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/Gtex_egene")
ggsave("eGenesvsTissue.pdf")
```
Now by Tissue Group:
```{r Plotting the raw Gtex data against Tissue Group}
setwd("C:/Users/Harry Young/Documents/Local Wokr/eGene")
Gtex_egene_SUMMARY_CountsvsTissueGroup = read_csv("Gtex_egene_SUMMARY_CountsvsTissueGroup.csv")
Gtex_egenes_plot_full = ggplot(Gtex_egene_SUMMARY_CountsvsTissueGroup, aes(x=tissue_group, y=group_count_mean)) + #Plot of SNPs NES vs beta from original dataset
  #geom_jitter(aes(color=NES)) +
  geom_col()+ # point plot with jitter to avoid overlap
  geom_errorbar(aes(ymin=group_count_mean-group_count_sd, ymax=group_count_mean+group_count_sd, width =0.2))+
  # scale_colour_viridis_c(direction=-1) + # colourblind friendly palette
  # scale_fill_viridis_c(direction=-1) +
  labs(title= "Mean Number of eGenes per Tissue Group", x= "Tissue Group", y= "Number of eGenes")+ # Lables
  geom_hline(aes(yintercept=0,))+ #  0 line
  theme(axis.text.x = element_text(angle = 70, hjust =1))  # text adjust

Gtex_egenes_plot_full

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/Gtex_egene") # SAVE it in dedicated plotting folder
ggsave("eGenesvsTissueGroup.pdf")
```

```{r gtex vs number ofsample data against Tissue}



Gtex_samples_count_plot_full = ggplot(Gtex_egene, aes(x=Tissue, y=`# RNASeq and Genotyped samples`, color = `# eGenes`,fill = `# eGenes`)) + #Plot of SNPs NES vs beta from original dataset
  #geom_jitter(aes(color=NES)) +
  geom_col()+ 
  scale_colour_viridis_c(direction=-1) + # colourblind friendly palette
  scale_fill_viridis_c(direction=-1) +
  labs(title= "Number of eGenes per Tissue", x= "Tissue", y= "Number of eGenes")+ # Lables
  geom_hline(aes(yintercept=0,))+ #  0 line
  theme(axis.text.x = element_text(angle = 70, hjust =1))  # text adjust

Gtex_samples_count_plot_full

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/Gtex_egene") # SAVE it in dedicated plotting folder
ggsave("Num_samplesvsTissue.pdf")
```

We can also view this as a correlation figure
```{r}

Gtex_egene = Gtex_egene %>% rename(eGenes = `# eGenes`,
                                  RNASeq_and_Genotyped_Samples = `# RNASeq and Genotyped samples`)


Correlation = ggplot(Gtex_egene[1:49,], aes(x=RNASeq_and_Genotyped_Samples, y=eGenes, color = Tissue)) + #Plot of SNPs NES vs beta from original dataset
  #geom_jitter(aes(color=NES)) +
  geom_point()+ 
  geom_text(data=subset(Gtex_egene, eGenes/RNASeq_and_Genotyped_Samples>45 | eGenes/RNASeq_and_Genotyped_Samples<20), aes(label=Tissue), vjust=-0.6, hjust=0.8)+
   # colourblind friendly palette
  scale_color_viridis_d() +
  labs(title= "Correlation of eGenes and Number of Samples", x= "RNASeq and Genotyped samples", y= "Number of eGenes") +# Lables
  theme(legend.position = "none")+ 
  geom_line(inherit.aes = TRUE, data = Gtex_egene[1:49,], stat="smooth", method = "lm", formula = y~x, alpha = 0.5, color = "black")
  
   #  0 line
   # text adjust

Correlation

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/Gtex_egene") # SAVE it in dedicated plotting folder
ggsave("eGenesvsnumberSamples.pdf")
```


## our df plotting
First step is to make sure that you are using the correctly filtered dataframe for no ambiguous or ukb-a data by loading in the ukaORambig_FINAL OR linkage removed set:  YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv dataframe as df:
```{r Reading in the FINAL df}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
# df = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL.csv")
df = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")
```
Another thing to consider is the use of a -log10 p scale to make it a bot more readable. First we have to remove any annoying true zero values that appear from time to time, here I replace them with a very small p-value of 1e-300
```{r}
df$p= ifelse(df$p==0, 1e-300,df$p)

df$logp=-log10(df$p)
df$logp_DIR =1
df$logp_DIR = if_else(df$NES_direction =="Negative", -1,1)
df$logp_DIR = df$logp*df$logp_DIR

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_csv(df, "YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")

```

Now whenever we can do a variety of plots by pointing our plotting function (ggplot) at our all-encompassing dataframe, df.



### NES vs tissue plots and expression data
First, download the overview of YOUR_GENE_NAME expression in the body from the Gtex search and save this.

Then it's useful to see what the original Gtex Data looks like in terms of tissues affected and direction of expression change:

```{r NES vs tissue FULL}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")

Gtex_YOUR_GENE_NAME_START = read_csv("Gtex_YOUR_GENE_NAME_START.csv")

NESvsTiss_full = ggplot(Gtex_YOUR_GENE_NAME_START, aes(x=Tissue, y=NES, color = `P-Value`)) + #Plot of SNPs NES vs beta from original dataset
  #geom_jitter(aes(color=NES)) +
  geom_point(position = position_jitterdodge())+ # point plot with jitter to avoid overlap
  scale_colour_viridis_c(direction=-1) + # colourblind friendly palette
  labs(title= "All YOUR_GENE_NAME Expression Changes", x= "Tissue", y= "NES")+ # Lables
  geom_hline(aes(yintercept=0,))+ #  0 line
  theme(axis.text.x = element_text(angle = 70, hjust =1))  # text adjust

NESvsTiss_full



setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/NES_vs_tissue_and_overview") # save in this dedicated folder
ggsave("NESvsTiss_full.pdf")
```

And compare this to the picture when we select all of the snps that also cause a trait from the phewas search:

```{r NES vs tissue that appear in phewas}
# Select only the gtex collumns of the df 
eQTL_from_Phewas = df%>%
  dplyr::select(rsid, NES, `P-Value`, Tissue, tissue_group)
# remove duplicated rows
eQTL_from_Phewas = unique(eQTL_from_Phewas)

NESvsTiss = ggplot(eQTL_from_Phewas, aes(x=Tissue, y=NES, color = `P-Value`)) + #Plot of SNPs NES vs beta
  #geom_jitter(aes(color=NES)) +
  geom_point(position = position_jitterdodge())+
  scale_colour_viridis_c(direction=-1) +
  labs(title= "YOUR_GENE_NAME Expression Changes Occuring in PheWAS Search", x= "Tissue", y= "NES")+
  geom_hline(aes(yintercept=0,))+
  theme(axis.text.x = element_text(angle = 70, hjust =1)) +
  geom_vline(aes(xintercept=0,))
NESvsTiss

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/NES_vs_tissue_and_overview")
ggsave("NESvsTiss_Phewas.pdf")
```

Shown together here: 

```{r plot together}
library(ggpubr)
ggarrange(NESvsTiss_full, NESvsTiss, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1)
```
### Full list of traitgroups:
A usefull plot to refer back to later is the full list of traitgroups to see where the gaps are. Here we create a count table the fill it with unique traitgroups from the database.

I tend to use relative nnumber of SNPs as It's the comparisons I'm interested in. If you want the raw numbers, simply set y=n instead of n/nrow(df)

NOTE: MAY HAVE TO UNCOMMENT THE LINE ylim(0,0.5) - this sets the y limits, if you want a specific range plotted

```{r The full traitgroup list}
setwd("C:/Users/Harry Young/Documents/Local Wokr/Trait and Tissue Groups")
Full_trait_database = read_csv("Full_trait_database.csv")

# set up the order to match later figures:
df$traitgroup = factor(df$traitgroup, levels =c("Body Fat/Size",
            "Metabolism (inc. Diabetes)",
             "Tumours (Benign/Cancer)",
            "Atrophy/Dystrophy", 
            "Congenital Defects", 
             "Cardiovascular Traits",
             "Blood/Vascular Traits",
             "Inflammation" , 
            "Respiratory",
             "Renal/Urinary",
            "Physical Activity",
           
             "Digestive Traits",
            "Nervous System/Brain",
             "Bone Traits (inc. Dental)",
            "Muscular/Tendon Traits",
            "Physical Injury",
            "Alcohol-Related Disease",
             "Life Span",
            "Female Specific Traits",
            "Other/Unspecified"
            ))

list_of_traitgroups = unique(Full_trait_database$traitgroup)
list_of_traitgroups = sort(list_of_traitgroups)
#print(list_of_traitgroups)
test = df%>% count(traitgroup)
for(trait in list_of_traitgroups){
  for(n in 1:nrow(test)){
    if(nrow(test[which(test$traitgroup==trait),])==0){
    test[nrow(test)+1,]= test[nrow(test)+1,] # make a new row
    test$traitgroup[nrow(test)] =trait
    test$n[nrow(test)] = 0
    }
  }
}

test= na.omit(test)
##PLOTTING:
Simple_traitgroup_plot = ggplot(test, aes(x=traitgroup, y =n/nrow(df))) + #Plot of Tissue vs trait for overlap
  geom_col()+
  #ylim(0,0.5)+
  scale_color_viridis_c()+
  labs(title= "Proportion of SNP-Trait Combinations per Traitgroup Overview", x ="Trait Group", y = paste("Proportion of SNP-Trait \nAssociations (n/total)"))+  #CHANGETHIS
  theme(axis.text.x = element_text(angle = 70, hjust =1))
Simple_traitgroup_plot


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots") #SAVE it
ggsave("Simple_numbervstraitgroup.pdf")



```

### Tissue Group and Trait Group overlap:
Use of geom_count where spot size is how many overlaps there are:

```{r Tiss-trait overlap}
Count_plot = ggplot(df, aes(x=traitgroup, y=tissue_group)) + #Plot of Tissue vs trait for overlap
  geom_count()+
  scale_color_viridis_c()+
  labs(title= "Overall YOUR_GENE_NAME Correlations", paste("Overall Count = ", nrow(df)), x ="Trait Group", y = "Tissue Group")+  #CHANGETHIS
  theme(axis.text.x = element_text(angle = 45, hjust =1))
Count_plot


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/Tissue_Group_and_Trait_Group_overlap") #SAVE it
ggsave("Tiss-trait_overlap.pdf")
```

We can also facet these plots to be split based on increased/decreased expression
```{r Overlap with facet by NES}
Count_facet = ggplot(df, aes(x=traitgroup, y=tissue_group)) + #Plot of Tissue vs trait for overlap
  geom_count()+
  scale_color_viridis_c()+
  labs(title= "YOUR_GENE_NAME Correlations by Change in Expression", caption = paste("Overall Count = ", nrow(df), "; Positive Count = ", nrow(df[which(df$NES>0),]), "; Negative Count = ", nrow(df[which(df$NES<0),])), x ="Trait Group", y = "Tissue Group")+  #CHANGETHIS
  theme(axis.text.x = element_text(angle = 45, hjust =1))+ 
  facet_grid(cols = vars(NES_direction))
Count_facet
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/Tissue_Group_and_Trait_Group_overlap") #SAVE it
ggsave("Tiss-trait_overlap_facet_by_NES.pdf")

```
### Snp against Tissue - Do any affect specific Tissues or multiple tissues?

Here it is important to use the df without SNPs in Linkage Disequilibrium. First we separate out the main dataframe back into only the Gtex categories and remove duplicated SNP-Tissue combos. 
```{r Number of snps per tissue plot USING LINKAGE, fig.height=14, fig.width=4}

LD_Gtex = df%>%
  dplyr::select(Tissue, tissue_group, rsid, `P-Value`, NES, position_gtex, chr_gtex, a, b, NES_direction)
LD_Gtex = unique(LD_Gtex)
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_csv(LD_Gtex, "YOUR_GENE_NAME_LDRED_Gtex.csv")



SNPcount = ggplot(LD_Gtex, aes(x=rsid,  fill = NES_direction)) + 
  geom_bar()+ # bar chart counting number of times rsid appears
  coord_flip()+
  scale_fill_viridis_d() + # I like this palette but you can remove it or change it 
  labs(title= "rsID Count" , x= "rsID", y = "Number of Tissues")+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))  # setting up x axis labels so they don't overlap + no legend

SNPcount


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") #SAVE it
ggsave("rsID_count_OVERVIEW.pdf")
```

#### Check whether we can use position instead of rsid - are there any cases where two rsid's match to the same location but different mutation?
 If output is TRUE,TRUE,TRUE and no printed list of positions, then no issue - NOT BEEN A PROBLEM WITH ALL GENES TESTED MARCH 2021!
```{r}

length(unique(df$rsid))==length(unique(df$position_gtex)) # If this is true then it is incredibly likely that they are

# more complex is to check where the position is the same, is the rsid different:
positions =df
positions$dupli_pos = duplicated(df$position_gtex)

positions = df %>% group_by(position_gtex, rsid) %>% summarise(count = length(position_gtex[!is.na(position_gtex)])) # table of how many time each combo of position and rsid is found
length(positions$position_gtex) == length(unique(positions$position_gtex)) # if true still looking good, means no position is repeated
length(positions$rsid) == length(unique(positions$rsid)) # if true still looking good, means no rsid is repeated

# extra test to make sure frequency table (summarise function) is working as expected and if not will give you an exceptions list
for(n in 1:nrow(positions)){
  if((nrow(df[which(df$position_gtex == positions$position_gtex[n]),]) == positions$count[n]) ==FALSE){
    print(positions$position_gtex[n])
  }
}

```

#### Option with positions instead of rsid
```{r Number of snps per tissue plot USING LINKAGE2, fig.height=14, fig.width=4}
#
LD_Gtex = df%>%
  dplyr::select(Tissue, tissue_group, position_gtex, rsid, `P-Value`, NES, position_gtex, chr_gtex, a, b, NES_direction)
LD_Gtex = unique(LD_Gtex)

LD_Gtex$position_gtex = as.character(LD_Gtex$position_gtex)

Chromosome = df$chr_phewas[1]

SNPcount = ggplot(LD_Gtex, aes(x=position_gtex,  fill = NES_direction)) + 
  geom_bar()+ # bar chart counting number of times rsid appears
  coord_flip()+
  scale_fill_viridis_d() + # I like this palette but you can remove it or change it 
  labs(title= "SNP Count" , x= paste0("Position (Chr ",Chromosome, ")"), y = "Number of Tissues")+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))  # setting up x axis labels so they don't overlap + no legend

SNPcount

LD_Gtex$position_gtex = as.numeric(LD_Gtex$position_gtex)

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") #SAVE it
ggsave("Position_count_OVERVIEW.pdf")
```
####Now the same thing but instead split by tissue:

```{r}
setwd("C:/Users/Harry Young/Documents/Local Wokr/Trait and Tissue Groups")
Full_tissue_database = read_csv("Full_tissue_database.csv")

list_of_tissues = unique(Full_tissue_database$RAW_Tissue)
list_of_tissues = sort(list_of_tissues)
#print(list_of_tissuegroups)
test = LD_Gtex %>% group_by(Tissue, NES_direction) %>% summarise(count = length(Tissue[!is.na(Tissue)])) # frequency by direction




for(tissue in list_of_tissues){
  for(n in 1:nrow(test)){
    if(nrow(test[which(test$Tissue==tissue),])==0){
    test[nrow(test)+1,]= test[nrow(test)+1,] # make a new row
    test$Tissue[nrow(test)] =tissue
    test$count[nrow(test)] = 0
    test$NES_direction[nrow(test)] = "Positive" # set it to either, doesn't matter as value is 0
    }
  }
}
test$NES_direction = factor(test$NES_direction, levels=c("Positive", "Negative"))

SNPcountperTissue = ggplot(test, aes(x=Tissue, y=count/nrow(LD_Gtex), fill=NES_direction)) + 
  geom_col()+ # bar chart counting how many times a tissue appears
  #ylim(0,0.5)+
  scale_fill_viridis_d(begin=1, end=0) + # I like this palette but you can remove it or change it 
  labs(title= "Tissue rsID Count" , x= "Tissue",  caption = paste("Overall Count = ", nrow(df)), y =paste("Proportion of rsIDs \n(n/total)"))+ #labels
  theme(axis.text.x = element_text(angle = 75, hjust =1), legend.position = "none")  # setting up x axis labels so they don't overlap + no legend

SNPcountperTissue

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") #SAVE it
ggsave("Tissue-rsid_count_OVERVIEW.pdf")


```
####And  by tissue group for a less huge plot:
```{r}
setwd("C:/Users/Harry Young/Documents/Local Wokr/Trait and Tissue Groups")
Full_tissue_database = read_csv("Full_tissue_database.csv")

list_of_tissuegroups = unique(Full_tissue_database$Tissue)
list_of_tissuegroups = sort(list_of_tissuegroups)
#print(list_of_tissuegroups)

test = LD_Gtex %>% group_by(tissue_group, NES_direction) %>% summarise(count = length(tissue_group[!is.na(tissue_group)])) # frequency by direction


LD_Gtex$tissue_group = ifelse(LD_Gtex$tissue_group=="Male_Specific_Tissue", "Male Specific Tissue", LD_Gtex$tissue_group)
# loop to add in the missing tissuegroups
for(tissuegroup in list_of_tissuegroups){
  for(n in 1:nrow(test)){
    if(nrow(test[which(test$tissue_group==tissuegroup),])==0){
    test[nrow(test)+1,]= test[nrow(test)+1,] # make a new row
    test$tissue_group[nrow(test)] =tissuegroup
    test$count[nrow(test)] = 0
    test$NES_direction[nrow(test)] = "Positive" # set it to either, doesn't matter as value is 0
    }
  }
}


test$NES_direction = factor(test$NES_direction, levels=c("Positive", "Negative"))
SNPcountperTissuegroup = ggplot(test, aes(x=tissue_group, y=count/nrow(LD_Gtex), fill=NES_direction)) + 
  geom_col()+ # bar chart counting how many times a tissue appears
  #ylim(0,0.5)+
  scale_fill_viridis_d(begin=1, end=0) + # I like this palette but you can remove it or change it 
  labs(title= "Tissue rsID Count" , x= "Tissue", y=paste("Proportion of rsIDs \n(n/total)"))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))  # setting up x axis labels so they don't overlap + no legend

SNPcountperTissuegroup

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") #SAVE it
ggsave("TissueGROUP-rsid_count_OVERVIEW.pdf")


```
#### Now using the Full Gtex dataset (BEFORE LD removal etc)
```{r}
setwd("C:/Users/Harry Young/Documents/Local Wokr/Trait and Tissue Groups")
Full_tissue_database = read_csv("Full_tissue_database.csv")
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
Gtex = read_csv("YOUR_GENE_NAME_Gtex_cleaned.csv")

# Assign Tissue groups to Gtex Dataframe
Gtex$tissue_group = Gtex$Tissue
Gtex$tissue_group_secondary = "none"
for( n in 1:nrow(Gtex)){# goes through each tissue group and binds these to the original data set
  for( i in 1:nrow(Full_tissue_database)){
    if(Gtex$tissue_group[n] == Full_tissue_database$RAW_Tissue[i]){
      Gtex$tissue_group[n] =  Full_tissue_database$Tissue[i]
      Gtex$tissue_group_secondary[n] =  Full_tissue_database$Secondary[i]
    }
  }
}


Gtex$NES_direction = ifelse(Gtex$NES > 0, "Positive", "Negative")
write_csv(Gtex, "YOUR_GENE_NAME_Gtex_cleaned.csv") 


list_of_tissuegroups = unique(Full_tissue_database$Tissue)
list_of_tissuegroups = sort(list_of_tissuegroups)
#print(list_of_tissuegroups)

test = Gtex %>% group_by(tissue_group, NES_direction) %>% summarise(count = length(tissue_group[!is.na(tissue_group)])) # frequency by direction

# for(n in 1:nrow(Gtex)){
#   if(Gtex$tissue_group[n] =="Male_Specific_Tissue"){
#     Gtex$tissue_group[n] = "Male Specific Tissue"
#   }
# }
Gtex$tissue_group = ifelse(Gtex$tissue_group=="Male_Specific_Tissue", "Male Specific Tissue", Gtex$tissue_group)
# loop to add in the missing tissuegroups
for(tissuegroup in list_of_tissuegroups){
  for(n in 1:nrow(test)){
    if(nrow(test[which(test$tissue_group==tissuegroup),])==0){
    test[nrow(test)+1,]= test[nrow(test)+1,] # make a new row
    test$tissue_group[nrow(test)] =tissuegroup
    test$count[nrow(test)] = 0
    test$NES_direction[nrow(test)] = "Positive" # set it to either, doesn't matter as value is 0
    }
  }
}


test$NES_direction = factor(test$NES_direction, levels=c("Positive", "Negative"))
SNPcountperTissuegroup = ggplot(test, aes(x=tissue_group, y=count/nrow(Gtex), fill=NES_direction)) + 
  geom_col()+ # bar chart counting how many times a tissue appears
  #ylim(0,0.5)+
  scale_fill_viridis_d(begin=1, end=0) + # I like this palette but you can remove it or change it 
  labs(title= "Tissue rsID Count" , x= "Tissue", y=paste("Proportion of rsIDs \n(n/total)"))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))  # setting up x axis labels so they don't overlap + no legend

SNPcountperTissuegroup

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") #SAVE it
ggsave("TissueGROUP-rsid_count_OVERVIEW_RED.pdf")


```
#### Correlation between RNA-seq/genotyped merged df - Checking the pattern isn't just beecause of this:
```{r Plotting the raw Gtex egene data against Tissue line graph}

df_YOUR_GENE_NAME_RED = df %>% dplyr::select(Tissue, tissue_group, `P-Value`) 
df_YOUR_GENE_NAME_RED = unique(df_YOUR_GENE_NAME_RED)

setwd("C:/Users/Harry Young/Documents/Local Wokr/eGene") 
Gtex_egene = read_csv("FINAL_Gtex_egene.csv")
Gtex_egene = Gtex_egene %>% rename(eGenes = `# eGenes`,
                                  RNASeq_and_Genotyped_Samples = `# RNASeq and Genotyped samples`)
Gtex_egene$tissue_group = ifelse(Gtex_egene$tissue_group=="Respiratory", "Respiratory Tissue", Gtex_egene$tissue_group)
# This Gtex_egene comes from earlier, need to work out whether I can doa read in step here...
Gtex_RNA_forcomp = Gtex_egene %>% dplyr::select(RNASeq_and_Genotyped_Samples, Tissue, tissue_group)
df_YOUR_GENE_NAME_forcomp = df_YOUR_GENE_NAME_RED %>% group_by(Tissue, tissue_group) %>% summarise(count = length(Tissue[!is.na(Tissue)]))

comparison_RNA = left_join(df_YOUR_GENE_NAME_forcomp, Gtex_RNA_forcomp, by=c("Tissue", "tissue_group"))

rsq <- function (x, y) cor(x, y) ^ 2
r2 = rsq(comparison_RNA[,3],comparison_RNA[,4])

Correlation = ggplot(comparison_RNA, aes(x=comparison_RNA$count, y=RNASeq_and_Genotyped_Samples, color = Tissue)) + #Plot of SNPs NES vs beta from original dataset
  #geom_jitter(aes(color=NES)) +
  geom_point()+ 
  #geom_text(data=subset(comparison_egene, eGenes/comparison_egene$count>45 | eGenes/comparison_egene$count<20), aes(label=Tissue), vjust=-0.6, hjust=0.8)+
   # colourblind friendly palette
  scale_color_viridis_d() +
  labs(title= paste0("Correlation of RNASeq and Genotyped samples \nand count from Gtex"), x= "SNP count from merged Dataset", y= "Number of RNASeq and Genotyped samples") +# Lables
  #theme(legend.position = "none")+ 
  geom_line(inherit.aes = TRUE, data = comparison_RNA[,3:4], stat="smooth", method = "lm", formula = y~x, alpha = 0.5, color = "black")
 
  
   #  0 line
   # text adjust

Correlation + annotate(geom="text",  x=12, y=20, label = paste0("r2 = ", round(r2[1],4)),
              fill="black")



setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") # SAVE it in dedicated plotting folder
ggsave("RNAvsMERGEDdfcount.pdf")


```

####Now, let's do the combo plot, taking all the SNPs in more than 1 tissue and seeeing what tissues they appear in:
This one will error and not work if no SNPs have two directions


```{r}

test = count(LD_Gtex, rsid) # setting up a frequency table
test = full_join(LD_Gtex, test, by = "rsid") # merging this frequency witht he original table

if(nrow(test[which(test$n>1),])>0){
SNPcountperTissueComb = ggplot(test[which(test$n>1),], aes(x=rsid,  y=Tissue, color = "black")) + # selecting only rsid's that appear more than once (i.e that change expression in more than one tissue)
  geom_count()+ # 
  scale_color_viridis_d(begin=0.2, end=0.8) + # I like this palette but you can remove it or change it 
  labs(title= "Tissue rsID Count" , x= "rsID")+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1), legend.position = "none")  # setting up x axis labels so they don't overlap + no legend

SNPcountperTissueComb

#BACKUP:
# SNPcountperTissueComb = ggplot(test[which(test$n>1),], aes(x=rsid,  fill=Tissue)) + # selecting only rsid's that appear more than once (i.e that change expression in more than one tissue)
#   geom_bar()+ # 
#   scale_fill_viridis_d(direction=1) + # I like this palette but you can remove it or change it 
#   labs(title= "Tissue rsID Count" , x= "Tissue")+ #labels
#   theme(axis.text.x = element_text(angle = 45, hjust =1))  # setting up x axis labels so they don't overlap + no legend
# 
# SNPcountperTissueComb

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") #SAVE it
ggsave("Tissue-rsid_count_COMBO_option2.pdf")

}
```

####Same again but using position for the eventual combo with gene diagram.
```{r, fig.width=10, fig.height=6}
if(nrow(test[which(test$n>1),])>0){
SNPposcountperTissueComb = ggplot(test, aes(x=position_gtex,  y=Tissue, color="black")) + # selecting only rsid's that appear more than once (i.e that change expression in more than one tissue)
  geom_point(size=2, alpha=0.5)+ # Base point plot
  geom_point(data=test[which(test$n>1),], aes(color="green"), alpha=0.7)+
  scale_color_viridis_d(begin=0.2, end=0.8, labels=c("All rsIDs", paste("rsIDs Affecting \n>1 Tissue"))) + # I like this palette but you can remove it or change it 
  labs(title= "Tissue rsID Count" , x= paste("Position, ( Chr",df$chr_phewas[1],")" ))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))
  #scale_x_continuous(breaks=seq(176500000,178000000, 100000))# setting up x axis labels so they don't overlap + no legend

SNPposcountperTissueComb

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") #SAVE it
ggsave("Tissue-Position_count_FOR_GENE_Diagram_All_HIGHLIGHT.pdf", width=10, height=6)
}
```
####Finally a zoom of our multiple tissue effectors
```{r}
if(nrow(test[which(test$n>1),])>0){
SNPposcountperTissueComb = ggplot(test[which(test$n>1),], aes(x=position_gtex,  y=Tissue, color="black")) + # selecting only rsid's that appear more than once (i.e that change expression in more than one tissue)
  geom_point(size=2, alpha=0.8)+ # Base point plot
  scale_color_viridis_d(begin=0.8, end=0.2, labels=c("All rsIDs", paste("rsIDs Affecting \n>1 Tissue"))) + # I like this palette but you can remove it or change it 
  labs(title= "Tissue rsID Count" , x= paste("Position, ( Chr",df$chr_phewas[1],")" ))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1),
        aspect.ratio = 3/5 )
  
  #scale_x_continuous(breaks=seq(176500000,178000000, 10000))# setting up x axis labels so they don't overlap + no legend

SNPposcountperTissueComb

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/snp_against_Tissue") #SAVE it
ggsave("Tissue-Position_count_FOR_GENE_Diagram_ZOOM.pdf")
}
```

# -log10(p) versions
Important: when plotting anyhting with  the traits in there, I use "p" which is teh p-value for the PheWAS trait NOT for the tissue expression change
### p vs trait split by trait group and Expression direction. Beta direction as color:
Next we can get a gauge on how many of the trait effects are positive and negative relative to increased or decreased expression whilst considering how confident we are that these are 'true' values by including a 5e-8 p value filter.

In this section, CARE WITH ylim() annotate()- you'll need to adjust both. 
* ylim works as ylim (a value, a value) - essentially you give it the range you want to plot
* example of annotate for two labels: annotate("label OR text OR rect", x = c(a1, b1), y= (a2, b2)), label = c("text for label 1", "text for label 2"), colour =c("textcolour1", "textcolour2"), fill=c("boxcolour1", "boxcolour2"))
** Specifically the x and y coordinates you may find confusing. If we consider the "positive" box, then, for y, I select the max value, and take off 15% of it (0.15*) to set the coordinate AND for x, the number of traitgroups with a small adjustment (-0.7) BUT ESSENTIALLY, just put in the coordinates based on x and y and it'll work


Firstly, we will look at the overview of all snps relative to traitgroups:

```{r NO CUTOFF Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME on Traits by logp}

df$beta_direction = factor(df$beta_direction, levels=c("Positive", "Negative"))
pvsTrait = ggplot(df, aes(x=traitgroup, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(alpha=0.6, position = position_jitterdodge())+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=-1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "-log(p)")+ #labels
  geom_hline(aes(yintercept=0,), alpha=0.3)+ # faint line at 0
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  #facet_grid(rows = vars(NES_direction))+ # facet splits the plot based on a variable, in this case NES direction
  #ylim(-200,200)+
  annotate("label",
           x=c(length(unique(df$traitgroup))-0.7,length(unique(df$traitgroup))-0.7),
           y=c(max(df$logp_DIR)-(0.15*max(df$logp_DIR)),min(df$logp_DIR)+(-0.15*min(df$logp_DIR))), 
           label=c("Positive","Negative"), 
           colour = c("white","white"), 
           fill =c("darkorchid4","darkorchid4"))
  
pvsTrait


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs traitgroup split Expression direction") #SAVE it
ggsave("pvalvstraitgroup_LOG.pdf")
```
####Raw count in each beta direction
```{r counts vs trait overview SEATTLE}
pos = df[which(df$NES_direction=="Positive"),]
neg = df[which(df$NES_direction=="Negative"),]

pvsTrait = ggplot()+ #Plot of Traitgroup vs SNP Count
  geom_bar(data= pos, aes(x=traitgroup, fill=beta_direction, y=..count..),  position = position_dodge2(width = 1, preserve = "single"))+
  geom_bar(data= neg, aes(x=traitgroup, fill=beta_direction, y=..count..*-1),  position = position_dodge2(width = 1, preserve = "single"))+##  alpha is transparancy from 0-1
  #ylim(-0.175,0.175)+
  geom_hline(yintercept=0, color ="gray70")+
  scale_fill_viridis_d(direction=-1) + # I like this palette but you can remove it or change it 
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= paste("Number of SNP-Trait \nAssociations"))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))+  # setting up x axis labels so they don't overlap
  #facet_grid(cols = vars(NES_direction)) # facet splits the plot based on a variable, in this case NES direction
  annotate("label",
           x=c(length(unique(df$traitgroup))-0.7,length(unique(df$traitgroup))-0.7),
            y=c(30,-30), 
           label=c("Positive","Negative"), 
           colour = c("white","white"), 
           fill =c("darkorchid4","darkorchid4"))
 
pvsTrait


  
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs traitgroup split Expression direction") #SAVE it
ggsave("COUNTvstraitgroup_overview_SEATLE.pdf")


```

####And  proportional count the snps in each beta direction:
```{r relative counts vs trait overview SEATTLE}

pvsTrait = ggplot()+ #Plot of Traitgroup vs SNP Count
  geom_bar(data= df[which(df$NES_direction=="Positive"),], aes(x=traitgroup, fill=beta_direction, y=..count../nrow(df[which(df$NES_direction=="Positive"),])),  position = position_dodge2(width = 1, preserve = "single"))+
  geom_bar(data= df[which(df$NES_direction=="Negative"),], aes(x=traitgroup, fill=beta_direction, y=(..count../nrow(df[which(df$NES_direction=="Negative"),]))*-1), position = position_dodge2(width = 1, preserve = "single"))+##  alpha is transparancy from 0-1
    geom_hline(yintercept=0, color ="gray70")+
  #ylim(-0.175,0.175)+
  scale_fill_viridis_d(direction=-1) + # I like this palette but you can remove it or change it 
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= paste("Relative Number of SNP-Trait \nAssociations (n/Total)"))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))+  # setting up x axis labels so they don't overlap
  #facet_grid(cols = vars(NES_direction)) # facet splits the plot based on a variable, in this case NES direction
  annotate("label",
           x=c(length(unique(df$traitgroup))-0.7,length(unique(df$traitgroup))-0.7),
           y=c(0.15,-0.15), 
           label=c("Positive","Negative"), 
           colour = c("white","white"), 
           fill =c("darkorchid4","darkorchid4"))
pvsTrait

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs traitgroup split Expression direction") #SAVE it
ggsave("COUNTvstraitgroup_REL_overview_SEATLE.pdf")


```
#### Proportional (WITHOUT other gene expression change (OGEC))
```{r relative counts NO OGEC vs trait overview SEATTLE, fig.width = 10, fig.height =10}

pvsTrait = ggplot()+ #Plot of Traitgroup vs SNP Count
  geom_bar(data= df[which(df$NES_direction=="Positive" & df$traitgroup!="Other/Unspecified"),], aes(x=traitgroup, fill=beta_direction, y=..count../nrow(df[which(df$NES_direction=="Positive"& df$traitgroup!="Other/Unspecified"),])),  position = position_dodge2(width = 1, preserve = "single"))+
  geom_bar(data= df[which(df$NES_direction=="Negative"& df$traitgroup!="Other/Unspecified"),], aes(x=traitgroup, fill=beta_direction, y=(..count../nrow(df[which(df$NES_direction=="Negative"& df$traitgroup!="Other/Unspecified"),]))*-1), position = position_dodge2(width = 1, preserve = "single"))+##  alpha is transparancy from 0-1
    geom_hline(yintercept=0, color ="gray70")+
  #ylim(-0.175,0.175)+
  scale_fill_viridis_d(direction=-1) + # I like this palette but you can remove it or change it 
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= paste("Relative Number of SNP-Trait \nAssociations (n/Total)"))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))+  # setting up x axis labels so they don't overlap
  #facet_grid(cols = vars(NES_direction)) # facet splits the plot based on a variable, in this case NES direction
  annotate("label",
           x=c(17,17),
           y=c(0.3,-0.27), 
           label=c("Positive","Negative"), 
           colour = c("white","white"), 
           fill =c("darkorchid4","darkorchid4"))
pvsTrait

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs traitgroup split Expression direction") #SAVE it
ggsave("COUNTvstraitgroup_REL_overview_SEATLE_NOOGEC.pdf")


```

Now for pvstrait but with 5e-8 p-val cutoff: 

```{r Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME on Traits}


pvsTraitCUTOFF = ggplot()+ #Plot of Traitgroup vs SNP Count
  geom_bar(data= df[which(df$NES_direction=="Positive" & df$p<5e-8),], aes(x=traitgroup, fill=beta_direction, y=..count../nrow(df[which(df$NES_direction=="Positive" & df$p<5e-8),])), position = position_dodge2(width = 1, preserve = "single"))+
  geom_bar(data= df[which(df$NES_direction=="Negative" & df$p<5e-8),], aes(x=traitgroup, fill=beta_direction, y=(..count../nrow(df[which(df$NES_direction=="Negative" & df$p<5e-8),]))*-1),  position = position_dodge2(width = 1, preserve = "single"))+##  alpha is transparancy from 0-1
  #ylim(-0.175,0.175)+
  scale_fill_viridis_d(direction=-1) + # I like this palette but you can remove it or change it 
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME (p<5e-8)" , x= "Trait Group", y= paste("Relative Number of SNP-Trait \nAssociations (n/Total)"))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))+  # setting up x axis labels so they don't overlap
  #facet_grid(cols = vars(NES_direction)) # facet splits the plot based on a variable, in this case NES direction
  annotate("label",
           x=c(length(unique(df[which(df$p<5e-8),]$traitgroup)),length(unique(df[which(df$p<5e-8),]$traitgroup))), 
           y=c(0.3,-0.3), 
           label=c("Positive","Negative"), 
           colour = c("white","white"),
           fill =c("darkorchid4","darkorchid4"))
pvsTraitCUTOFF

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs traitgroup split Expression direction") #SAVE it
ggsave("pvalvstraitgroup_MIAMI_CUTOFF.pdf")

```

Importantly we must consider that these counts are somewhat influenced by the number of egenes or samples from the initial Gtex data aquisition. In other words, if a tissue has been sampled more then there will be more discrepency in genomes and so more SNPs. So you have to refer back to the initial count or egene plot of Gtex. Maybe I can put in some sort of adjusted plot here? COME BACK TO THIS

### P vs Trait By Traitgroup
Next, we will look at every trait organised by traitgroup:

In order to get this plot in a way where the text isn't overlapping, you have to make it pretty big. This means it isn't massively useful for looking at within this markdown (see below). But the pdf in the test folder is pretty useful. However for obvious reasons you'll want to tweak this to get a useful figure for a4 paper.
```{r,    fig.width= 45, fig.height= 15}
pvsTrait_bytraitgroup = ggplot(df, aes(x=trait, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(alpha=0.6, position = position_jitterdodge())+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Traits Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait by Traitgroup", y= "-log(p)")+ #labels
  geom_hline(aes(yintercept=0,), alpha=0.3)+ # faint line at 0
  theme(axis.text.x = element_text(angle = 70, hjust =1)) + # setting up x axis labels so they don't overlap
  facet_grid(cols = vars(traitgroup), scales = "free_x", switch = 'x') 
  #geom_text(data=ann_text)
  #ylim(-200,200)
  #annotate("label",x=c(19.3,19.3), y=c(175,-175), label=c("Positive","Negative"), colour = c("white","white"), fill =c("darkorchid4","darkorchid4"))# change x and y coordinates to move the floating labels
  
pvsTrait_bytraitgroup


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_bytraitgroup.pdf", width = 30, height =15)# Actually setting some dimensions due to long names
```
With cutoff:

```{r Traits Effected by SNPs that Change in Expression of YOUR_GENE_NAME}

pvsTrait_fullfacet = ggplot(df[which(df$p<5e-8),], aes(x=trait, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(alpha=0.6, position = position_jitterdodge())+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=-1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Traits Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait by Traitgroup", y= "-log(p)")+ #labels
  geom_hline(aes(yintercept=0,), alpha=0.3)+ # faint line at 0
  theme(axis.text.x = element_text(angle = 70, hjust =1)) + # setting up x axis labels so they don't overlap
  facet_grid(cols = vars(traitgroup), scales = "free_x", switch = 'x') 
  #geom_text(data=ann_text)
  #ylim(-200,200)
  #annotate("label",x=c(19.3,19.3), y=c(175,-175), label=c("Positive","Negative"), colour = c("white","white"), fill =c("darkorchid4","darkorchid4"))# change x and y coordinates to move the floating labels
pvsTrait_fullfacet

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvalvstrait_bytraitgroupCUTOFF.pdf", width = 10, height =6)# Actually setting some dimensions due to long names
```
Now that plot is a big one and often needs tweaking so do change the height and width in the code and then check it in the folder you've saved it in. Not as automated but at this point it's kind of up to you on how much you want to change the plotting to suit your own needs.

####For example here ONLY INFLAMMATION:


```{r, fig.width=6, fig.height=10}

if(nrow(df[which(df$traitgroup =="Inflammation"),])>0){
pvsTrait_byINFL = ggplot(df[which(df$traitgroup =="Inflammation"),], aes(x=trait, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(position = position_jitterdodge(), size =2)+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=-1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "-log(p)")+ #labels
  geom_hline(aes(yintercept=0,), alpha=0.3)+# faint line at 0
  geom_hline(aes(yintercept=4,), alpha=0.3, color="red")+
  geom_hline(aes(yintercept=-4,), alpha=0.3, color="red")+
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  #facet_grid(rows = vars(NES_direction))+ # facet splits the plot based on a variable, in this case NES direction
  annotate("label",
           x=c(10.5,10.5), 
           y=c(8,-6), 
           label=c("Positive","Negative"), 
           colour = c("white","white"), 
           fill =c("darkorchid4","darkorchid4"))
pvsTrait_byINFL

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_INFL_LOG.pdf", width = 6, height =10)# Actually setting some dimensions due to long names
}
```


```{r, fig.width=6, fig.height=7}

if(nrow(df[which(df$traitgroup =="Inflammation"),])>0){
pvsTrait_byINFL = ggplot(df[which(df$traitgroup =="Inflammation"),], aes(x=trait, y=logp_DIR, color=beta_direction, shape =tissue_group)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(position = position_jitterdodge(), size =2)+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=-1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "-log(p)")+ #labels
  geom_hline(aes(yintercept=0,), alpha=0.3)+# faint line at 0
  geom_hline(aes(yintercept=4,), alpha=0.3, color="red")+
  geom_hline(aes(yintercept=-4,), alpha=0.3, color="red")+
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  #facet_grid(rows = vars(NES_direction))+ # facet splits the plot based on a variable, in this case NES direction
  annotate("label",
           x=c(9.5,9.5), 
           y=c(8,-6), 
           label=c("Positive","Negative"), 
           colour = c("white","white"), 
           fill =c("darkorchid4","darkorchid4"))
pvsTrait_byINFL

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_INFL_LOG_TISCOL.pdf", width = 6, height =7)# Actually setting some dimensions due to long names
}
```
#### New INFL with subcat
Can either do it from scracth or just load the file I made and add to it.
```{r, fig.width=10, fig.height=10}
if(nrow(df[which(df$traitgroup =="Inflammation"),])>0){

subcat = df[which(df$traitgroup =="Inflammation"),]


  
pvsTrait_byINFL = ggplot(subcat, aes(x=trait, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(position = position_jitterdodge(), size =1)+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=-1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Inflammation Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "-log(p)")+ #labels
  geom_hline(yintercept=0, alpha=0.3)+# faint line at 0
  # geom_hline(yintercept=4, alpha=0.3, color="red")+
  # geom_hline(yintercept=-4, alpha=0.3, color="red")+
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  facet_grid( cols = vars(Subcat), scales="free_x", space="free_x") # facet splits the plot based on a variable, in this case NES direction
  # annotate("label",
  #          x=c(10.5,10.5), 
  #          y=c(8,-6), 
  #          label=c("Positive","Negative"), 
  #          colour = c("white","white"), 
  #          fill =c("darkorchid4","darkorchid4"))
pvsTrait_byINFL

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_INFL_LOG_TISCOL.pdf", width = 12, height =10)# Actually setting some dimensions due to long names
}
```
#### By body type INCOMPLETE!!!


```{r, }

if(nrow(df[which(df$traitgroup =="Body Fat/Size"),])>0){
subcat = df[which(df$traitgroup =="Body Fat/Size"),]
pvsTrait_bybody = ggplot(subcat, aes(x=trait, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(position = position_jitterdodge(), size =1)+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=-1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Body Fat/Size Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "-log(p)")+ #labels
  geom_hline(yintercept=0, alpha=0.3)+# faint line at 0
  geom_hline(yintercept=4, alpha=0.3, color="red")+
  geom_hline(yintercept=-4, alpha=0.3, color="red")+
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  facet_grid(cols = vars(Subcat), scales="free", space="free_x") # facet splits the plot based on a variable, in this case NES direction
  # annotate("label",
  #          x=c(10.5,10.5), 
  #          y=c(8,-6), 
  #          label=c("Positive","Negative"), 
  #          colour = c("white","white"), 
  #          fill =c("darkorchid4","darkorchid4"))
pvsTrait_bybody

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_BODY_LOG_TISCOL.pdf")# Actually setting some dimensions due to long names
}

```
#### Bar chart of bodyfat/type
```{r}
if(nrow(df[which(df$traitgroup =="Body Fat/Size"),])>0){
subcat$beta_direction = factor(subcat$beta_direction, levels=c("Positive", "Negative"))
pvsTrait_bybody = ggplot() + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
    geom_bar(data= subcat[which(subcat$NES_direction=="Positive"),], aes(x=trait, fill=beta_direction, y=..count../nrow(subcat[which(subcat$NES_direction=="Positive"),])),  position = position_dodge2(width = 1, preserve = "single"))+
  geom_bar(data= subcat[which(subcat$NES_direction=="Negative"),], aes(x=trait, fill=beta_direction, y=(..count../nrow(subcat[which(subcat$NES_direction=="Negative"),]))*-1),  position = position_dodge2(width = 1, preserve = "single"))+##  alpha
  scale_fill_viridis_d(direction=-1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Body Fat/Size Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "Relative Count")+ #labels
  geom_hline(yintercept=0, alpha=0.3)+# faint line at 0
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  facet_grid(cols = vars(Subcat), scales="free", space="free_x") # facet splits the plot based on a variable, in this case NES direction
  # annotate("label",
  #          x=c(10.5,10.5), 
  #          y=c(8,-6), 
  #          label=c("Positive","Negative"), 
  #          colour = c("white","white"), 
  #          fill =c("darkorchid4","darkorchid4"))
pvsTrait_bybody

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_BODY_LOG_TISCOL_BAR.pdf")# Actually setting some dimensions due to long names
}
```
#### By Kidney Traits INCOMPLETE!!!


```{r, }
if(nrow(df[which(df$traitgroup =="Renal/Urinary"),])>0){
subcat = df[which(df$traitgroup =="Renal/Urinary"),]
subcat$beta_direction = factor(subcat$beta_direction, levels=c("Positive", "Negative"))

pvsTrait_bykidney = ggplot(subcat, aes(x=trait, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(position = position_jitterdodge(), size =1)+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=-1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Kidney Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "-log(p)")+ #labels
  geom_hline(yintercept=0, alpha=0.3)+# faint line at 0
  geom_hline(yintercept=4, alpha=0.3, color="red")+
  geom_hline(yintercept=-4, alpha=0.3, color="red")+
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  facet_grid(cols = vars(Subcat), scales="free", space="free_x") # facet splits the plot based on a variable, in this case NES direction
  # annotate("label",
  #          x=c(10.5,10.5), 
  #          y=c(8,-6), 
  #          label=c("Positive","Negative"), 
  #          colour = c("white","white"), 
  #          fill =c("darkorchid4","darkorchid4"))
pvsTrait_bykidney

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_Kidney_LOG_TISCOL.pdf")# Actually setting some dimensions due to long names
}

```
####For example here ONLY Respiratory Function:
```{r, fig.width = 6, fig.height =10}
if(nrow(df[which(df$traitgroup =="Respiratory"),])>0){
# uncomment and run the lines if needed - to add more categories in a grepl manner OLD VERSION
pvsTrait_byRF = ggplot(df[which(df$traitgroup =="Respiratory"),], aes(x=trait, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(alpha=0.6, position = position_jitterdodge())+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "-log(p)")+ #labels
  geom_hline(aes(yintercept=0,), alpha=0.3)+# faint line at 0
  geom_hline(aes(yintercept=4,), alpha=0.3, color="red")+
  geom_hline(aes(yintercept=-4,), alpha=0.3, color="red")+
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  facet_grid(cols = vars(Subcat), scales="free", space="free_x")+ # facet splits the plot based on a variable, in this case NES direction
  annotate("label",
           x=c(5,5), 
           y=c(15,-15), 
           label=c("Positive","Negative"), 
           colour = c("white","white"), 
           fill =c("darkorchid4","darkorchid4"))
pvsTrait_byRF

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_respFunc_LOG.pdf", width = 6, height =10)# Actually setting some dimensions due to long names
}

```

####Also, just Other gene expression change for interests sake :
```{r, fig.width = 6, fig.height =10}
if(nrow(df[which(df$Subcat =="Other Gene Expression Change"),])>0){
# uncomment and run the lines if needed - to add more categories in a grepl manner OLD VERSION
pvsTrait_byRF = ggplot(df[which(df$Subcat =="Other Gene Expression Change"),], aes(x=trait, y=logp_DIR, color=beta_direction)) + #Plot of Traitgroup vs p (P-Value is the Gtex P not PS p)
  # geom_jitter(aes(color=NES)) + # Jitter can be nicer but i think i prefer point with jitterdodge
  geom_point(alpha=0.6, position = position_jitterdodge())+ #  alpha is transparancy from 0-1
  scale_colour_viridis_d(direction=1, ) + # I like this palette but you can remove it or change it - green/blue option begin=0.2, end=0.7
  labs(title= "Trait Groups Effected by SNPs that Change in Expression of YOUR_GENE_NAME" , x= "Trait Group", y= "-log(p)")+ #labels
  geom_hline(aes(yintercept=0,), alpha=0.3)+# faint line at 0
  geom_hline(aes(yintercept=4,), alpha=0.3, color="red")+
  geom_hline(aes(yintercept=-4,), alpha=0.3, color="red")+
  theme(axis.text.x = element_text(angle = 45, hjust =1)) + # setting up x axis labels so they don't overlap
  facet_grid(cols = vars(Subcat), scales="free", space="free_x")+ # facet splits the plot based on a variable, in this case NES direction
  annotate("label",
           x=c(5,5), 
           y=c(15,-15), 
           label=c("Positive","Negative"), 
           colour = c("white","white"), 
           fill =c("darkorchid4","darkorchid4"))
pvsTrait_byRF

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("pvsTrait_OEGC_LOG.pdf", width = 6, height =10)# Actually setting some dimensions due to long names
}
```

### Number of positive and negative beta values per trait -HUGE, unwieldly plot.
For each trait it might also be nice to see how many positive and negative beta values there are for each expression type.

For this we use the same basic plotting setup but using geom_bar and no specific 'y=' setting in aes().
```{r Number of SNPs that Change Expression of YOUR_GENE_NAME and Effect a Trait, fig.width=30,fig.height=30}

num_of_SNPs_by_beta = ggplot()+ #Plot of Traitgroup vs SNP Count
  geom_bar(data= df[which(df$NES_direction=="Positive"),], aes(x=trait, color=beta_direction, y=..count../nrow(df[which(df$NES_direction=="Positive"),])), alpha=0.6, position = position_dodge2(width = 1, preserve = "single"))+
  geom_bar(data= df[which(df$NES_direction=="Negative"),], aes(x=trait, color=beta_direction, y=(..count../nrow(df[which(df$NES_direction=="Negative" ),]))*-1), alpha=0.6, position = position_dodge2(width = 1, preserve = "single"))+##  alpha is transparancy from 0-1
  #ylim(-0.175,0.175)+
  scale_colour_viridis_d(direction=1) + # I like this palette but you can remove it or change it 
  labs(title= "Number of SNPs that Change in Expression of YOUR_GENE_NAME and Effect a Trait" , x= "Trait Group", y= paste("Relative Number of SNP-Trait \nAssociations (n/Total)"))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))+ # setting up x axis labels so they don't overlap
  facet_grid(cols = vars(traitgroup), scales = "free_x", switch = 'x') 
  #annotate("label",x=c(10.6,10.6), y=c(0.2,-0.17), label=c("Positive","Negative"), colour = c("white","white"), fill =c("darkorchid4","darkorchid4"))
num_of_SNPs_by_beta

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/p vs trait split by trait group and Expression direction") #SAVE it
ggsave("num_of_SNPs_by_beta_CUTOFF.pdf", width = 10, height =6)# Actually setting some dimensions due to long names
```

# Part 2


### Preamble, data setup steps
YOU MUST DO THESE MANUAL STEPS BEFORE KNITTING 

First you have to look up the exon table and regulatory features from ensembl. Then bind it to the new merged df and the original YOUR_GENE_NAME_Gtex_cleaned df. This step is a little more manual. Unfortunately gene to gene it's hard to write a consistent bit of code for finding introns and exons and cleaning up the df to be what you want it to be. Maybe I can come back here in the final tidying steps! 
#### 1. Gene exon/intron setup
This section now grabs all exons from all available protein coding transcripts from ensembl. 

*First go to the ensembl website (or click the ensembl link from the expression table from your gtex search. 
*Then for your gene, click each transcript ID, then the "About this transcript: This has x exons" above the table and download the dataset from the bottom table that appears below that gives you the exon and intron information.
*Save into a dedicated folder: All_Exon_Options. as "your_file_name.csv"
*Repeat for all possible transcripts
```{r assigning gene regions to df and gtex}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Ensembl/All_Exon_Options")

temp = list.files(pattern="*.csv")
myfiles = lapply(temp, read_csv)

for(n in 1:length(myfiles)){
  myfiles[[n]]$ID=rep(n,nrow(myfiles[[n]])) # sets ID as a value from 1:length of list
  myfiles[[n]]$`Start Phase`= as.character(myfiles[[n]]$`Start Phase`)
  myfiles[[n]]$`End Phase`= as.character(myfiles[[n]]$`End Phase`)# sorts out start phase ambiguity
}


YOUR_GENE_NAME_structure =bind_rows(myfiles, .id="id") # merges the list of dataframes into one dataframe

YOUR_GENE_NAME_structure = YOUR_GENE_NAME_structure[!grepl("stream", YOUR_GENE_NAME_structure$`Exon / Intron`),] # remove the 5' and 3' up/downstream regions
YOUR_GENE_NAME_structure$EI <- !!rowSums(sapply(YOUR_GENE_NAME_structure, grepl, pattern = "ENSE"))
YOUR_GENE_NAME_structure$EI = if_else(YOUR_GENE_NAME_structure$EI ==TRUE, "Exon", "Intron")

# Finally just making a simple to use mini version of the main table of exons/introns
YOUR_GENE_NAME_structure_FIN = YOUR_GENE_NAME_structure %>% dplyr::select( Start, End, EI)
YOUR_GENE_NAME_structure_FIN = unique(YOUR_GENE_NAME_structure_FIN)


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Ensembl")
write_csv(YOUR_GENE_NAME_structure_FIN, "YOUR_GENE_NAME_structure_FIN.csv")
write_csv(YOUR_GENE_NAME_structure, "YOUR_GENE_NAME_structure_FULL.csv")

```
Now to load in and modify the main df and Gtex in order to have information on where the SNPS are in relation the the gene
```{r}


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Ensembl")
YOUR_GENE_NAME_structure_FIN =read_csv("YOUR_GENE_NAME_structure_FIN.csv")
YOUR_GENE_NAME_structure =read_csv( "YOUR_GENE_NAME_structure_FULL.csv")
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
df = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")
Gtex = read_csv("YOUR_GENE_NAME_Gtex_cleaned.csv")




limitsSTART = YOUR_GENE_NAME_structure[which.max(YOUR_GENE_NAME_structure$Start),]
limitsEND = YOUR_GENE_NAME_structure[which.min(YOUR_GENE_NAME_structure$End),]
limits =rbind(limitsSTART,limitsEND)

exons = YOUR_GENE_NAME_structure[which(YOUR_GENE_NAME_structure$EI=="Exon"),] # select just exon rows
exons = exons %>% dplyr::select(EI, Start, End) # simplify to raw exon boundaries
exons = unique(exons) # remove all duplicates

# setting up a "within Gene region" column by testing if position is between the limits
df$Within_Gene_Region = "No"
for(n in 1:nrow(df)){
  if(limitsSTART$Start[1] >=df$position_gtex[n] & df$position_gtex[n]>=limitsEND$End[1]){
    df$Within_Gene_Region[n] = "Yes"
  }
}


# setting up a "within Gene region" column by testing if position is within ANY exons, if not autmatically set to intron
df$Intron_or_Exon = "Intron" # confusingly YOUR_GENE_NAME runs backwards so all the signs are flipped to make sense : START>POS>END
for( n in 1:nrow(df)){
  for(i in 1:nrow(exons)){
    if(exons$Start[i]>=df$position_gtex[n] & df$position_gtex[n]>=exons$End[i]){
      df$Intron_or_Exon[n] = "Exon"
    }
  }

}
# setting up Neither option in intron/exon - overwrites intron with neither
for(n in 1:nrow(df)){
  if(df$Within_Gene_Region[n]=="No"){
    df$Intron_or_Exon[n] = "Neither"
  }
}


# repeated for Gtex RAW data
Gtex$Within_Gene_Region = "No"
for(n in 1:nrow(Gtex)){
  if(limitsSTART$Start[1] >=Gtex$position_gtex[n] & Gtex$position_gtex[n]>=limitsEND$End[1]){
    Gtex$Within_Gene_Region[n] = "Yes"
  }
}



Gtex$Intron_or_Exon = "Intron" # confusingly YOUR_GENE_NAME runs backwards so all the signs are flipped to make sense : START>POS>END
for( n in 1:nrow(Gtex)){
  for(i in 1:nrow(exons)){
    if(exons$Start[i]>=Gtex$position_gtex[n] & Gtex$position_gtex[n]>=exons$End[i]){
      Gtex$Intron_or_Exon[n] = "Exon"
    }
  }

}

for(n in 1:nrow(Gtex)){
  if(Gtex$Within_Gene_Region[n]=="No"){
    Gtex$Intron_or_Exon[n] = "Neither"
  }
}



 # Only run these next 2 lines if it's the first time, merges changes with the previous data file for simplicity
write_csv(df, "YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")
write_csv(Gtex, "YOUR_GENE_NAME_Gtex_cleaned.csv")

```
#### 2. Regulatory region setup
NOW AUTOMATED
Next is creating the regulatory build column - again needs downloading for the ensembl website which must be done separately depending on exactly what you want. I simply found the limits of my dataframes position_gtex, and searched the ensembl regulatory 102 - Human_regulatory_features_ch38 - chr 2 : pos(min max from df) using the "biomart" section of the ensembl website. 

This simply looks to see if the SNP position is within any of the regulatory regions and binds that to the column reg_region. with the default set to none. NOTE: This doesn't necessarily mean that there is no regulatory region here it simply means that there is not one according to that regulatory database. Genomics is a complicated and fickle beast based on best guesses!

**I have now created an automated version of this using the biomaRt package**
1. Set Mart to funcgen - (regulatory features) and data to hsapiens_regulatory_feature
2. Next choose chromosome and start/end based on Gtex data and merged
3. Run getBM() to pull out human regulatory features within this region
```{r Assigning regulatory regions}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Ensembl")


ensembl = useMart("ENSEMBL_MART_FUNCGEN")
ensembl = useDataset("hsapiens_regulatory_feature",mart=ensembl)
# make varibles for chromosome and start and end + fudge factor (to include final points)
chr = df$chr_phewas[1]
YOUR_GENE_NAME_region_st = min(Gtex$position_gtex-10000) # 9640000
YOUR_GENE_NAME_region_fin = max(Gtex$position_gtex+10000) #  11400000
filter_values=list(chr,YOUR_GENE_NAME_region_st,YOUR_GENE_NAME_region_fin)
temp = getBM(attributes=c("chromosome_name", "chromosome_start", "chromosome_end", "feature_type_name"), 
      filters = c("chromosome_name", "start", "end"),
      values = filter_values, 
      mart = ensembl)

write_csv(temp, "YOUR_GENE_NAME_full_REG_region.csv")
```
Now we assign those reg features to df and gtex dataframes
```{r}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Ensembl")
reg_feat = read_csv("YOUR_GENE_NAME_full_REG_region.csv") # from biomart from ensembl - 
# setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
# df = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv") # from before
# df, and Gtex from previous CHUNK



df$reg_region ="None" # default set to "None"

for(n in 1:nrow(df)){
  for(i in 1:nrow(reg_feat)){
    if(df$position_gtex[n]>= reg_feat$chromosome_start[i] & df$position_gtex[n]<=reg_feat$chromosome_end[i]){ # if our snp is within one of these boundaries
      df$reg_region[n] = reg_feat$feature_type_name[i]
    }
  }
}

#repeated for Gtex
Gtex$reg_region ="None" # default set to "None"

for(n in 1:nrow(Gtex)){
  for(i in 1:nrow(reg_feat)){
    if(Gtex$position_gtex[n]>= reg_feat$chromosome_start[i] & Gtex$position_gtex[n]<=reg_feat$chromosome_end[i]){ # if our snp is within one of these boundaries
      Gtex$reg_region[n] = reg_feat$feature_type_name[i]
    }
  }
}
# repeated for the merged data pre LD/ambig/ukba removal
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
df_merge = read_csv("YOUR_GENE_NAME_merge_GTEX_PHEWAS_betacor_ambig_grouped.csv")




df_merge$reg_region ="None" # default set to "None"

for(n in 1:nrow(df_merge)){
  for(i in 1:nrow(reg_feat)){
    if(df_merge$position_gtex[n]>= reg_feat$chromosome_start[i] & df_merge$position_gtex[n]<=reg_feat$chromosome_end[i]){ # if our snp is within one of these boundaries
      df_merge$reg_region[n] = reg_feat$feature_type_name[i]
    }
  }
}



write_csv(df_merge, "YOUR_GENE_NAME_merge_GTEX_PHEWAS_betacor_ambig_grouped_reg.csv")
# I'm just overiding this file with the new one for simplicity but you can make a new file if you see fit
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_csv(df, "YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")
write_csv(Gtex, "YOUR_GENE_NAME_Gtex_cleaned_REG.csv")

```

Ok so this next bit is getting more and more complicated... Essentially There are a lot of transcripts. So what is an exon or an intron varies on where you look. My first instinct is to just use the all inclusive dataset and just have a whole load of overlapping rectangles to represent every possible region, but it may get messy.

DO THESE NEXT FEW STEPS for YOUR_GENE_NAME KEAP1 ORMDL3 and ATP5f1
First load in main dataframe with bound regions and the structure as a dataframe called *rectangles*
```{r load in main dataframe with bound regions and the structure as a dataframe called rectangles, results=FALSE, message=FALSE}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
df_merge = read_csv("YOUR_GENE_NAME_merge_GTEX_PHEWAS_betacor_ambig_grouped_reg.csv")
Gtex = read_csv("YOUR_GENE_NAME_Gtex_cleaned_REG.csv")
df = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Ensembl")
reg_feat = read_csv("YOUR_GENE_NAME_full_REG_region.csv") 
YOUR_GENE_NAME_rectangles = read_csv("YOUR_GENE_NAME_structure_FIN.csv") # from before
```

Now, importantly, both for the linear and curved gene diagram the leg work remains the same. 
* Define the regions by having start, end and feature columns (as in YOUR_GENE_NAME_rectangles). 
* Next define the y axis as the minimum p value to the maximum p value (pmin to pmax) Plot these as rectangles where the introns and exons take up the middle two quadrants and the reg regions fill the rest.
* Overlay your SNPs from the appropriate dataframe with x = position and y = p value  

First, we need to take the regulatory feature dataframe (downloaded form ensembl BioMART - see start of section) and clean it to look like YOUR_GENE_NAME_rectangles
```{r Setting up reg feature dataframe }
# Now simplifying the regulatroy region page down
reg_feat_for_bind = reg_feat[,2:4]
# sorting the names to be the same as the YOUR_GENE_NAME_rectangles 
reg_feat_for_bind = reg_feat_for_bind %>% rename(Start=chromosome_start,
                                                 End=chromosome_end,
                                                 EI=feature_type_name)

# and finally binding the two table together
gene_and_reg = rbind(reg_feat_for_bind, YOUR_GENE_NAME_rectangles)

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Ensembl") # saving in the Ensembl folder
write_csv(gene_and_reg, "YOUR_GENE_NAME_and_reg_feat_FOR_GENE_DIAGRAM.csv")

```

### Gene diagram plotting
Next we begin plotting the basic linear setup. I have also included the 'random y value' version if you'd prefer not to consider p-value. **NOTE:** _RED - indicates the reduced SNP set associated with searching the Gtex SNPs in PheWAS and removing SNPS based on LD. _G indicates the original Gtex set of SNPs WITHOUT LD removal.
**NOTE 2:** In the plotting lines there is a legend.position = "none" line. This removes the legend for a higher resolution plot, However it is important to have at least one with the legend for figure building. For this, comment out the line and save as _Legend.  

#### Color setup preamble
This section shifts around a fair bit in terms of which variables are in each plot and I wanted to have a consistent colour scheme throughout. So this chunk serves to set up and save colour information.
```{r}
cols = c("CTCF Binding Site" = "#C39BD3",
         "Enhancer" = "#196F3D70", 
         "Exon" = "#2C3E50", 
         "Intron"= "#56B4E9",
         "None" = "#C0392B",
         "Open chromatin" = "#AAB7B8",
         "Promoter" ="#1ABC9C",
         "Promoter Flanking Region" ="#ABEBC6",
         "TF binding site" ="#E67E22"
         )
# Full Tissue List
   # Blood = "#CC5500",
   # Cultured_Cells = "#00FFFF",
   # Digestive ="#A7C7E7",
   # Endocrine = "#FF4433",
   # Fat = "#E0115F",
   # Female_Reproductive_Tissue = "#022A0E",
   # Heart = "#80461B",
   # Lymphatic ="#023020",
   # Male_Specific_Tissue ="#FFA500",
   # Mammary = "#E9846E",
   # Muscle = "#FFBF00",
   # Nervous = "#90EE90",
   # Respiratory = "#D673C9",
   # Skin = "#00A36C",
   # Vascular ="#630330"
```


####0. LEGACY, moved to ARCHIVE 

  
####1. GTEX SNPs (all, pre-merge and LD removal)
```{r Linear _G diagram}
# select relevent columns, position, which reg_region the SNP is in, and the P-value of this SNP-Tissue correlation
df_G = Gtex %>% dplyr::select(position_gtex, reg_region, `P-Value`) 
# Setting up a -logP column to make it more readable
df_G$logp=-log10(df_G$`P-Value`)
# df = as.data.frame(df$position_gtex)
df_G=unique(df_G) # Creating a reduced version of the positions of the snps from the final dataframe
df_G = arrange(df_G, position_gtex) # Sort numerically by position
df_G = as.data.frame(df_G) 

# Next is assigning y values (rectangle height) to `P-Value`
pmin = min(df_G$logp) # assign min and max p values
pmax = max(df_G$logp)

# pmax-pmin/4 essentially means the range of p-values divided by 4, i.e. the middle 2 quadrants
gene_and_reg$yminD = if_else(gene_and_reg$EI =="Intron" | gene_and_reg$EI =="Exon", pmin+((pmax-pmin)/4),pmin) # setting up y values for the rectangles
gene_and_reg$ymaxD = if_else(gene_and_reg$EI =="Intron" | gene_and_reg$EI =="Exon", pmax-((pmax-pmin)/4),pmax)# if it is an intron use the first value, anything else the second
# number of snps plotted:
Unique_snps = length(unique(df_G$position_gtex))
# Setting up the plot - not commented in great detail
gene_structure_G = ggplot()+
  geom_rect(gene_and_reg[which(gene_and_reg$EI !="Intron" & gene_and_reg$EI !="Exon"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD,  fill=EI ),  alpha=0.8)+
  geom_rect(gene_and_reg[which(gene_and_reg$EI =="Intron"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD, fill = EI),  alpha=0.6)+
  geom_rect(gene_and_reg[which(gene_and_reg$EI =="Exon"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD, color=EI))+
  geom_point(aes(x= df_G$position_gtex, y=df_G$logp, color = df_G$reg_region), size=0.6)+ # alpha=0 , add this for _legend plot
  theme(panel.grid.major.x = element_line(size=0.2),
        panel.grid.minor.x = element_line(size=0.05),
        axis.text.x = element_text(angle = 70, hjust =1),
        legend.title = element_blank(),
        legend.position = "none", 
        aspect.ratio = 0.1,
        panel.background = element_rect(fill = "white",
                                        colour = "white"))+
  labs(title= "YOUR_GENE_NAME Gene Region Diagram (Gtex SNPs)" , x= "Position", y= "-log(p)",caption = paste("Overall number of SNPs =", Unique_snps))+
  scale_fill_manual(values=cols)+
  scale_color_manual(values=cols)+
  scale_x_reverse()

gene_structure_G

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
ggsave("Gene_structure_G.pdf")

```
#INCOMPLETE - for removal depending on meeting outcome  
####2a. Gtex SNPs (P-Value) after merge
```{r df_gtex_RED}

df_gtex_RED = df_merge %>% dplyr::select(position_gtex, reg_region, `P-Value`)
df_gtex_RED$logp=-log10(df_gtex_RED$`P-Value`)
# df_RED = as.data.frame(df$position_gtex)
df_gtex_RED=unique(df_gtex_RED) # Creating a reduced version of the positions of the snps from the final dataframe
df_gtex_RED = arrange(df_gtex_RED, position_gtex)
df_gtex_RED = as.data.frame(df_gtex_RED)

# Next is assigning y values (rectangle height) to `P-Value`
pmin = min(df_gtex_RED$logp)
pmax = max(df_gtex_RED$logp)
gene_and_reg$yminD = if_else(gene_and_reg$EI =="Intron" | gene_and_reg$EI =="Exon", pmin+((pmax-pmin)/4),pmin) # setting up arbitrary y values for the rectangles
gene_and_reg$ymaxD = if_else(gene_and_reg$EI =="Intron" | gene_and_reg$EI =="Exon", pmax-((pmax-pmin)/4),pmax)# if it is an intron use the first value, anything else the second

# number of snps plotted:
Unique_snps = length(unique(df_gtex_RED$position_gtex))

#plot:
gene_structure_RED = ggplot()+
  geom_rect(gene_and_reg[which(gene_and_reg$EI !="Intron" & gene_and_reg$EI !="Exon"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD,  fill=EI ),  alpha=0.8)+
  geom_rect(gene_and_reg[which(gene_and_reg$EI =="Intron"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD, fill = EI),  alpha=0.6)+
  geom_rect(gene_and_reg[which(gene_and_reg$EI =="Exon"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD, color=EI))+
  geom_point(aes(x= df_gtex_RED$position_gtex, y=df_gtex_RED$logp, color = df_gtex_RED$reg_region), size=0.6)+
  theme(panel.grid.major.x = element_line(size=0.2),
        panel.grid.minor.x = element_line(size=0.05),
        axis.text.x = element_text(angle = 70, hjust =1),
        legend.title = element_blank(),
        legend.position = "none",
        aspect.ratio = 0.1,
        panel.background = element_rect(fill = "white",
                                        colour = "white"))+
  labs(title= "YOUR_GENE_NAME Gene Region Diagram (Gtex after Merge SNPs)" , x= "Position", y= "-log(p)",caption = paste("Overall number of SNPs =", Unique_snps))+
  scale_fill_manual(values=cols)+
  scale_color_manual(values=cols)+
  scale_x_reverse()




gene_structure_RED


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
ggsave("Gene_structure_gtex_from_merge.pdf")
```
####2b. Gtex SNPs (P-Value) after merge and LD removal
```{r df_gtex_RED2}
df_gtex_RED = df %>% dplyr::select(position_gtex, reg_region, `P-Value`)
df_gtex_RED$logp=-log10(df_gtex_RED$`P-Value`)
# df_RED = as.data.frame(df$position_gtex)
df_gtex_RED=unique(df_gtex_RED) # Creating a reduced version of the positions of the snps from the final dataframe
df_gtex_RED = arrange(df_gtex_RED, position_gtex)
df_gtex_RED = as.data.frame(df_gtex_RED)

# Next is assigning y values (rectangle height) to `P-Value`
pmin = min(df_gtex_RED$logp)
pmax = max(df_gtex_RED$logp)
gene_and_reg$yminD = if_else(gene_and_reg$EI =="Intron" | gene_and_reg$EI =="Exon", pmin+((pmax-pmin)/4),pmin) # setting up arbitrary y values for the rectangles
gene_and_reg$ymaxD = if_else(gene_and_reg$EI =="Intron" | gene_and_reg$EI =="Exon", pmax-((pmax-pmin)/4),pmax)# if it is an intron use the first value, anything else the second

# number of snps plotted:
Unique_snps = length(unique(df_gtex_RED$position_gtex))

#Plot:
gene_structure_RED = ggplot()+
  geom_rect(gene_and_reg[which(gene_and_reg$EI !="Intron" & gene_and_reg$EI !="Exon"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD,  fill=EI ),  alpha=0.8)+
  geom_rect(gene_and_reg[which(gene_and_reg$EI =="Intron"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD, fill = EI),  alpha=0.6)+
  geom_rect(gene_and_reg[which(gene_and_reg$EI =="Exon"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD, color=EI))+
  geom_point(aes(x= df_gtex_RED$position_gtex, y=df_gtex_RED$logp, color = df_gtex_RED$reg_region), size=0.6)+
  theme(panel.grid.major.x = element_line(size=0.2),
        panel.grid.minor.x = element_line(size=0.05),
        axis.text.x = element_text(angle = 70, hjust =1),
        legend.title = element_blank(),
        legend.position = "none",
        aspect.ratio = 0.1,
        panel.background = element_rect(fill = "white",
                                        colour = "white"))+
  labs(title= "YOUR_GENE_NAME Gene Region Diagram (Gtex after Merge and LD removal SNPs)" , x= "Position", y= "-log(p)",caption = paste("Overall number of SNPs =", Unique_snps))+
  scale_fill_manual(values=cols)+
  scale_color_manual(values=cols)+
  scale_x_reverse()




gene_structure_RED


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
ggsave("Gene_structure_gtex_RED.pdf")
```

####3. PheWAS SNPs (p value). - Flipped version for sankey in archive
```{r df_PheWAS_RED}

df_PheWAS_RED = df %>% dplyr::select(position_gtex, reg_region, p)
df_PheWAS_RED$logp=-log10(df_PheWAS_RED$p)
# df_RED = as.data.frame(df$position_gtex)
df_PheWAS_RED=unique(df_PheWAS_RED) # Creating a reduced version of the positions of the snps from the final dataframe
df_PheWAS_RED = arrange(df_PheWAS_RED, position_gtex)
df_PheWAS_RED = as.data.frame(df_PheWAS_RED)

# Next is assigning y values (rectangle height) to `P-Value`
pmin = min(df_PheWAS_RED$logp)
pmax = max(df_PheWAS_RED$logp)
gene_and_reg$yminD = if_else(gene_and_reg$EI =="Intron" | gene_and_reg$EI =="Exon", pmin+((pmax-pmin)/4),pmin) # setting up arbitrary y values for the rectangles
gene_and_reg$ymaxD = if_else(gene_and_reg$EI =="Intron" | gene_and_reg$EI =="Exon", pmax-((pmax-pmin)/4),pmax)# if it is an intron use the first value, anything else the second

# number of snps plotted:
Unique_snps = length(unique(df_PheWAS_RED$position_gtex))

#Plot:
gene_structure_RED_P = ggplot()+
  geom_rect(gene_and_reg[which(gene_and_reg$EI !="Intron" & gene_and_reg$EI !="Exon"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD,  fill=EI ),  alpha=0.8)+
  geom_rect(gene_and_reg[which(gene_and_reg$EI =="Intron"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD, fill = EI),  alpha=0.6)+
  geom_rect(gene_and_reg[which(gene_and_reg$EI =="Exon"),], mapping=aes(xmin=Start, xmax=End, ymin=yminD, ymax=ymaxD, color=EI))+
  geom_point(aes(x= df_PheWAS_RED$position_gtex, y=df_PheWAS_RED$logp, color = df_PheWAS_RED$reg_region), size=0.6)+
  theme(panel.grid.major.x = element_line(size=0.2),
        panel.grid.minor.x = element_line(size=0.05),
        axis.text.x = element_text(angle = 70, hjust =1),
        legend.title = element_blank(),
        legend.position = "none",
        aspect.ratio = 0.1,
        panel.background = element_rect(fill = "white",
                                        colour = "white"))+
  # Must add in the reverse here as it will go on the right side of the figure!
  #scale_y_reverse()+ # This can be used to reduce plotting region to remove outliers limits=c(54.596000,pmin)
  labs(title= "YOUR_GENE_NAME Gene Region Diagram (Gtex-PheWAS SNPs)" , x= "Position", y= "-log(p)",caption = paste("Overall number of SNPs =", Unique_snps))+
  scale_fill_manual(values=cols)+
  scale_color_manual(values=cols)+
  scale_x_reverse()




gene_structure_RED_P


setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
ggsave("Gene_structure_PheWAS_RED.pdf")
```

####4. Half-circular Gene diagrams (For Circos Figure)
This Section has been moved before the Circos proper because we are still making gene diagrams using only the data we have setup in this "Gene Diagram" section. However for an explanation of circlize and tutorials on how to use it, please do read the next section "Circos".

All of these are also available with SNPs coloured based on the reg_region they are in (uncomment those lines), Also, change pch from 20 to 21 for rings as opposed to points which can look better, 
##### Curved Gtex (all, pre-merge and LD removal)
```{r Curved Gene diagrams Gtex_G}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
library(circlize) # in preamble too
# Similar to above, select relevent columns, remove duplicates and 



df_for_circle = Gtex %>% dplyr::select(chr_gtex, position_gtex, reg_region, `P-Value`)
df_for_circle = unique(df_for_circle)
df_for_circle$y = runif(nrow(df_for_circle)) # random y value between 0 and 1 - stddist
df_for_circle$logp = -log(df_for_circle$`P-Value`)

pmax=df_for_circle$logp[which.max(df_for_circle$logp)]
pmin=df_for_circle$logp[which.min(df_for_circle$logp)]


# colours_for_rect = c("palegreen3","gray70","violet","cyan3","gold","red3","black","skyblue1")

gene_and_reg$color = ifelse( gene_and_reg$EI== "Enhancer", "#196F3D", 
                             ifelse(gene_and_reg$EI== "Open chromatin", "#AAB7B8",
                                     ifelse(gene_and_reg$EI== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(gene_and_reg$EI== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(gene_and_reg$EI== "TF binding site", "#E67E22",
                                                             ifelse(gene_and_reg$EI== "Promoter", "#1ABC9C",
                                                                     ifelse(gene_and_reg$EI== "Exon", "#2C3E50",
                                                                           ifelse(gene_and_reg$EI== "Intron", "#56B4E9","FAIL"))))))))
# Add in colours for snps:
# df_for_circle$color = ifelse( df_for_circle$reg_region== "Enhancer", "#196F3D",
#                              ifelse(df_for_circle$reg_region== "Open chromatin", "#AAB7B8",
#                                      ifelse(df_for_circle$reg_region== "Promoter Flanking Region", "#ABEBC6",
#                                              ifelse(df_for_circle$reg_region== "CTCF Binding Site", "#C39BD3",
#                                                      ifelse(df_for_circle$reg_region== "TF binding site", "#E67E22",
#                                                              ifelse(df_for_circle$reg_region== "Promoter", "#1ABC9C",
#                                                                      ifelse(df_for_circle$reg_region== "Exon", "#2C3E50",
#                                                                            ifelse(df_for_circle$reg_region== "Intron", "#56B4E9","#C0392B"))))))))

circos.clear()
# .par() start and gap degree for setting partial rings up!

pdf("Curved_gene_diagram_G.pdf") # add _color to name to add color for snps


circos.par("track.height" = 0.1, start.degree = 180 , gap.degree= 180, canvas.xlim =c(-1,1), canvas.ylim =c(-0.3,1)) # radius of all circles = 1 so this means 1/10 is each track
# Track 1 - Gene Information
circos.initialize(df_for_circle$chr_gtex, x = df_for_circle$position_gtex) # defining the x axis for the tracks
# next we add in a track
circos.track(df_for_circle$chr_gtex, y = df_for_circle$logp, 
             panel.fun = function(x, y) {
               # These 3 lines are alter the outer label (in this case chrNUMBER)
               circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] + mm_y(15),
                           CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
                           adj = c(0, 0.5), cex = 0.6)
               # These lines are really important and WILL need modifying to get it looking good on the circle, digits = number of significant figures
               # by = is tick rate
               circos.axis(labels.cex = 0.4, 
                           direction ="outside", 
                           major.at = seq(signif(df_for_circle$position_gtex[which.min(df_for_circle$position_gtex)], digits = 4),                                                                            signif(df_for_circle$position_gtex[which.max(df_for_circle$position_gtex)], digits = 4), 
                                          by = 50000)) # specifically this "by=" will have to be changed based on how crowded it looks
               # Thes alter teh y axis ticks and will again need altering
               circos.yaxis(labels.cex=0.4, 
                            labels.niceFacing = TRUE, side="left", 
                            at = seq(from = as.integer(min(df_for_circle$logp)), 
                                     to = as.integer(max(df_for_circle$logp)), 
                                     length = 4))
             }) 

circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$Start, ybottom=pmin, xright=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$End, ytop=pmax, col=gene_and_reg$color, border=NA)
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$End, ytop=pmax-0.25*(pmax-pmin), col="skyblue1", border="skyblue1")
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$End, ytop=pmax-0.25*(pmax-pmin), col="black", border="black")
circos.trackPoints(sectors=df_for_circle$chr_gtex, x=df_for_circle$position_gtex,y= df_for_circle$logp, pch = 25, cex = 0.3, col = "mediumblue") # add in col=df_for_circle$color

dev.off()
```

##### Curved Gtex (all, pre-merge and LD removal) + Colour
```{r Curved Gene diagrams Gtex_G}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
library(circlize) # in preamble too
# Similar to above, select relevent columns, remove duplicates and 



df_for_circle = Gtex %>% dplyr::select(chr_gtex, position_gtex, reg_region, `P-Value`)
df_for_circle = unique(df_for_circle)
df_for_circle$y = runif(nrow(df_for_circle)) # random y value between 0 and 1 - stddist
df_for_circle$logp = -log(df_for_circle$`P-Value`)

pmax=df_for_circle$logp[which.max(df_for_circle$logp)]
pmin=df_for_circle$logp[which.min(df_for_circle$logp)]


# colours_for_rect = c("palegreen3","gray70","violet","cyan3","gold","red3","black","skyblue1")

gene_and_reg$color = ifelse( gene_and_reg$EI== "Enhancer", "#196F3D", 
                             ifelse(gene_and_reg$EI== "Open chromatin", "#AAB7B8",
                                     ifelse(gene_and_reg$EI== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(gene_and_reg$EI== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(gene_and_reg$EI== "TF binding site", "#E67E22",
                                                             ifelse(gene_and_reg$EI== "Promoter", "#1ABC9C",
                                                                     ifelse(gene_and_reg$EI== "Exon", "#2C3E50",
                                                                           ifelse(gene_and_reg$EI== "Intron", "#56B4E9","FAIL"))))))))
# Add in colours for snps:
df_for_circle$color = ifelse( df_for_circle$reg_region== "Enhancer", "#196F3D",
                             ifelse(df_for_circle$reg_region== "Open chromatin", "#AAB7B8",
                                     ifelse(df_for_circle$reg_region== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(df_for_circle$reg_region== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(df_for_circle$reg_region== "TF binding site", "#E67E22",
                                                             ifelse(df_for_circle$reg_region== "Promoter", "#1ABC9C",
                                                                     ifelse(df_for_circle$reg_region== "Exon", "#2C3E50",
                                                                           ifelse(df_for_circle$reg_region== "Intron", "#56B4E9","#C0392B"))))))))


# Define rectangles dataframe for the coloured ring underneath the plot - OPTIONAL
range = signif(max(df_for_circle$position_gtex),4)+50000 - signif(min(df_for_circle$position_gtex),4)
scale_bar = seq(from =signif(min(df_for_circle$position_gtex),4) , to = signif(max(df_for_circle$position_gtex),4)+50000 , by= range/10 )
scale_bar =as.data.frame(scale_bar)
names(scale_bar) = "x"
scale_bar$colour = "#9430c2" # - purple
scale_bar$colour[seq(1, nrow(scale_bar), 2)]="#bd680d" # fills every other row with orange

circos.clear()
# .par() start and gap degree for setting partial rings up!

pdf("Curved_gene_diagram_G_Colour.pdf") # add _color to name to add color for snps


circos.par("track.height" = 0.1, start.degree = 180 , gap.degree= 180, canvas.xlim =c(-1,1), canvas.ylim =c(-0.3,1)) # radius of all circles = 1 so this means 1/10 is each track
# Track 1 - Gene Information
circos.initialize(df_for_circle$chr_gtex, x = df_for_circle$position_gtex) # defining the x axis for the tracks
# next we add in a track
circos.track(df_for_circle$chr_gtex, y = df_for_circle$logp, 
             panel.fun = function(x, y) {
               # These 3 lines are alter the outer label (in this case chrNUMBER)
               circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] + mm_y(15),
                           CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
                           adj = c(0, 0.5), cex = 0.6)
               # These lines are really important and WILL need modifying to get it looking good on the circle, digits = number of significant figures
               # by = is tick rate
               circos.axis(labels.cex = 0.4, 
                           direction ="outside", 
                           major.at = seq(signif(df_for_circle$position_gtex[which.min(df_for_circle$position_gtex)], digits = 4),                                                                            signif(df_for_circle$position_gtex[which.max(df_for_circle$position_gtex)], digits = 4), 
                                          by = 50000)) # specifically this "by=" will have to be changed based on how crowded it looks
               # These alter the y axis ticks and will again need altering
               circos.yaxis(labels.cex=0.4, 
                            labels.niceFacing = TRUE, side="left", 
                            at = seq(from = as.integer(min(df_for_circle$logp)), 
                                     to = as.integer(max(df_for_circle$logp)), 
                                     length = 4))
             }) 

circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$Start, ybottom=pmin, xright=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$End, ytop=pmax, col=gene_and_reg$color, border=NA)
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$End, ytop=pmax-0.25*(pmax-pmin), col="skyblue1", border="skyblue1")
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$End, ytop=pmax-0.25*(pmax-pmin), col="black", border="black")
circos.trackPoints(sectors=df_for_circle$chr_gtex, x=df_for_circle$position_gtex,y= df_for_circle$logp, pch = 25, cex = 0.3, col=df_for_circle$color) # add in col=df_for_circle$color
circos.rect(xleft=scale_bar$x[1:nrow(scale_bar)-1], CELL_META$cell.ylim[1] - mm_y(1.5), xright=scale_bar$x[2:nrow(scale_bar)], ytop=CELL_META$cell.ylim[1], col=scale_bar$colour, border=NA) #0-((max(df_for_circle$logp))/10)

dev.off()
```
##### CURVED Gtex SNPs (P-Value) after merge and LD removal
```{r Curved Gene diagrams Gtex_RED}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
library(circlize) # in preamble too
# Similar to above, select relevent columns, remove duplicates and 



df_for_circle = df %>% dplyr::select(chr_gtex, position_gtex, reg_region, `P-Value`)
df_for_circle = unique(df_for_circle)
df_for_circle$y = runif(nrow(df_for_circle)) # random y value between 0 and 1 - stddist
df_for_circle$logp = -log(df_for_circle$`P-Value`)

pmax=df_for_circle$logp[which.max(df_for_circle$logp)]
pmin=df_for_circle$logp[which.min(df_for_circle$logp)]


# colours_for_rect = c("palegreen3","gray70","violet","cyan3","gold","red3","black","skyblue1")

gene_and_reg$color = ifelse( gene_and_reg$EI== "Enhancer", "#196F3D", 
                             ifelse(gene_and_reg$EI== "Open chromatin", "#AAB7B8",
                                     ifelse(gene_and_reg$EI== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(gene_and_reg$EI== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(gene_and_reg$EI== "TF binding site", "#E67E22",
                                                             ifelse(gene_and_reg$EI== "Promoter", "#1ABC9C",
                                                                     ifelse(gene_and_reg$EI== "Exon", "#2C3E50",
                                                                           ifelse(gene_and_reg$EI== "Intron", "#56B4E9","FAIL"))))))))

# # Add in colours for snps:
# df_for_circle$color = ifelse( df_for_circle$reg_region== "Enhancer", "#196F3D",
#                              ifelse(df_for_circle$reg_region== "Open chromatin", "#AAB7B8",
#                                      ifelse(df_for_circle$reg_region== "Promoter Flanking Region", "#ABEBC6",
#                                              ifelse(df_for_circle$reg_region== "CTCF Binding Site", "#C39BD3",
#                                                      ifelse(df_for_circle$reg_region== "TF binding site", "#E67E22",
#                                                              ifelse(df_for_circle$reg_region== "Promoter", "#1ABC9C",
#                                                                      ifelse(df_for_circle$reg_region== "Exon", "#2C3E50",
#                                                                            ifelse(df_for_circle$reg_region== "Intron", "#56B4E9","#C0392B"))))))))

circos.clear()
# .par() start and gap degree for setting partial rings up!

pdf("Curved_gene_diagram_RED.pdf") # add in _color if using coloured snps


circos.par("track.height" = 0.1, start.degree = 180 , gap.degree= 180, canvas.xlim =c(-1,1), canvas.ylim =c(-0.3,1)) # radius of all circles = 1 so this means 1/10 is each track
# Track 1 - Gene Information
circos.initialize(df_for_circle$chr_gtex, x = df_for_circle$position_gtex) # defining the x axis for the tracks
# next we add in a track
circos.track(df_for_circle$chr_gtex, y = df_for_circle$logp, 
             panel.fun = function(x, y) {
               circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] + mm_y(15),
                           CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
                           adj = c(0, 0.5), cex = 0.6)
               circos.axis(labels.cex = 0.4, direction ="outside", major.at = seq(signif(df_for_circle$position_gtex[which.min(df_for_circle$position_gtex)]-500000, digits = 4),
                                                                                  signif(df_for_circle$position_gtex[which.max(df_for_circle$position_gtex)], digits = 4), 
                                                                                  by = 50000))
               circos.yaxis(labels.cex=0.4, 
                            labels.niceFacing = TRUE, side="left", 
                            at = seq(from = as.integer(min(df_for_circle$logp)), 
                                     to = as.integer(max(df_for_circle$logp)), 
                                     length = 4))
             })

circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$Start, ybottom=pmin, xright=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$End, ytop=pmax, col=gene_and_reg$color, border=NA)
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$End, ytop=pmax-0.25*(pmax-pmin), col="skyblue1", border="skyblue1")
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$End, ytop=pmax-0.25*(pmax-pmin), col="black", border="black")
circos.trackPoints(sectors=df_for_circle$chr_gtex, x=df_for_circle$position_gtex,y= df_for_circle$logp, pch = 25, cex = 0.3, col= "mediumblue") # add in col=df_for_circle$color

dev.off()
```
##### CURVED Gtex SNPs (P-Value) after merge and LD removal + Colour
This plot also has the purple and orange split for figure building - commented out for the moment - remove from release -INCOMPLETE:
```{r Curved Gene diagrams Gtex_RED}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
library(circlize) # in preamble too
# Similar to above, select relevent columns, remove duplicates and 



df_for_circle = df %>% dplyr::select(chr_gtex, position_gtex, reg_region, `P-Value`)
df_for_circle = unique(df_for_circle)
df_for_circle$y = runif(nrow(df_for_circle)) # random y value between 0 and 1 - stddist
df_for_circle$logp = -log(df_for_circle$`P-Value`)

pmax=df_for_circle$logp[which.max(df_for_circle$logp)]
pmin=df_for_circle$logp[which.min(df_for_circle$logp)]


# colours_for_rect = c("palegreen3","gray70","violet","cyan3","gold","red3","black","skyblue1")

gene_and_reg$color = ifelse( gene_and_reg$EI== "Enhancer", "#196F3D", 
                             ifelse(gene_and_reg$EI== "Open chromatin", "#AAB7B8",
                                     ifelse(gene_and_reg$EI== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(gene_and_reg$EI== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(gene_and_reg$EI== "TF binding site", "#E67E22",
                                                             ifelse(gene_and_reg$EI== "Promoter", "#1ABC9C",
                                                                     ifelse(gene_and_reg$EI== "Exon", "#2C3E50",
                                                                           ifelse(gene_and_reg$EI== "Intron", "#56B4E9","FAIL"))))))))

# # Add in colours for snps:
df_for_circle$color = ifelse( df_for_circle$reg_region== "Enhancer", "#196F3D",
                             ifelse(df_for_circle$reg_region== "Open chromatin", "#AAB7B8",
                                     ifelse(df_for_circle$reg_region== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(df_for_circle$reg_region== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(df_for_circle$reg_region== "TF binding site", "#E67E22",
                                                             ifelse(df_for_circle$reg_region== "Promoter", "#1ABC9C",
                                                                     ifelse(df_for_circle$reg_region== "Exon", "#2C3E50",
                                                                           ifelse(df_for_circle$reg_region== "Intron", "#56B4E9","#C0392B"))))))))

# Define rectangles dataframe for the coloured ring underneath the plot - OPTIONAL
range = signif(max(df_for_circle$position_gtex),4)+50000 - signif(min(df_for_circle$position_gtex),4)
scale_bar = seq(from =signif(min(df_for_circle$position_gtex),4) , to = signif(max(df_for_circle$position_gtex),4)+50000 , by= range/10 )
scale_bar =as.data.frame(scale_bar)
names(scale_bar) = "x"
scale_bar$colour = "#9430c2" # - purple
scale_bar$colour[seq(1, nrow(scale_bar), 2)]="#bd680d" # fills every other row with orange

### Getting started with circos
circos.clear()
# .par() start and gap degree for setting partial rings up!

pdf("Curved_gene_diagram_RED_colour.pdf") # add in _color if using coloured snps


circos.par("track.height" = 0.1, start.degree = 180 , gap.degree= 180, canvas.xlim =c(-1,1), canvas.ylim =c(-0.3,1)) # radius of all circles = 1 so this means 1/10 is each track
# Track 1 - Gene Information
circos.initialize(df_for_circle$chr_gtex, x = df_for_circle$position_gtex) # defining the x axis for the tracks
# next we add in a track
circos.track(df_for_circle$chr_gtex, y = df_for_circle$logp, 
             panel.fun = function(x, y) {
               circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] + mm_y(15),
                           CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
                           adj = c(0, 0.5), cex = 0.6)
               circos.axis(labels.cex = 0.4, direction ="outside", major.at = seq(signif(df_for_circle$position_gtex[which.min(df_for_circle$position_gtex)]-500000, digits = 4),
                                                                                  signif(df_for_circle$position_gtex[which.max(df_for_circle$position_gtex)], digits = 4), 
                                                                                  by = 50000))
               circos.yaxis(labels.cex=0.4, 
                            labels.niceFacing = TRUE, side="left", 
                            at = seq(from = as.integer(min(df_for_circle$logp)), 
                                     to = as.integer(max(df_for_circle$logp)), 
                                     length = 4))
             }) 

circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$Start, ybottom=pmin, xright=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$End, ytop=pmax, col=gene_and_reg$color, border=NA)
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$End, ytop=pmax-0.25*(pmax-pmin), col="skyblue1", border="skyblue1")
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$End, ytop=pmax-0.25*(pmax-pmin), col="black", border="black")
circos.trackPoints(sectors=df_for_circle$chr_gtex, x=df_for_circle$position_gtex,y= df_for_circle$logp, pch = 25, cex = 0.3, col=df_for_circle$color) # add in col=df_for_circle$color

# Adding in the scale bar - Find absolute values for y
circos.rect(xleft=scale_bar$x[1:nrow(scale_bar)-1], CELL_META$cell.ylim[1] - mm_y(1.5), xright=scale_bar$x[2:nrow(scale_bar)], ytop=CELL_META$cell.ylim[1], col=scale_bar$colour, border=NA) #0-((max(df_for_circle$logp))/10)
#circos.rect(xleft=scale_bar$x[1:nrow(scale_bar)-1], ybottom=0-((max(df_for_circle$logp))/3), xright=scale_bar$x[2:nrow(scale_bar)], ytop=0-((max(df_for_circle$logp))/10), col=scale_bar$colour, border=NA) #0-((max(df_for_circle$logp))/10)

dev.off()
```
##### CURVED PheWAS SNPs (p Value) after merge and LD removal
```{r Curved Gene diagrams PHEWAS_RED}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
library(circlize) # in preamble too
# Similar to above, select relevent columns, remove duplicates and 



df_for_circle = df %>% dplyr::select(chr_gtex, position_gtex,reg_region, p)
df_for_circle = unique(df_for_circle)
df_for_circle$y = runif(nrow(df_for_circle)) # random y value between 0 and 1 - stddist
df_for_circle$logp = -log(df_for_circle$p)
# This dataset has one incredibly significant SNP so option to remove it for nicer plot here:
#df_for_circle = df_for_circle[which(df_for_circle$logp<400),]

pmax=df_for_circle$logp[which.max(df_for_circle$logp)]
pmin=df_for_circle$logp[which.min(df_for_circle$logp)]


# colours_for_rect = c("palegreen3","gray70","violet","cyan3","gold","red3","black","skyblue1")

gene_and_reg$color = ifelse( gene_and_reg$EI== "Enhancer", "#196F3D", 
                             ifelse(gene_and_reg$EI== "Open chromatin", "#AAB7B8",
                                     ifelse(gene_and_reg$EI== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(gene_and_reg$EI== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(gene_and_reg$EI== "TF binding site", "#E67E22",
                                                             ifelse(gene_and_reg$EI== "Promoter", "#1ABC9C",
                                                                     ifelse(gene_and_reg$EI== "Exon", "#2C3E50",
                                                                           ifelse(gene_and_reg$EI== "Intron", "#56B4E9","FAIL"))))))))

# Add in colours for snps:
# df_for_circle$color = ifelse( df_for_circle$reg_region== "Enhancer", "#196F3D",
#                              ifelse(df_for_circle$reg_region== "Open chromatin", "#AAB7B8",
#                                      ifelse(df_for_circle$reg_region== "Promoter Flanking Region", "#ABEBC6",
#                                              ifelse(df_for_circle$reg_region== "CTCF Binding Site", "#C39BD3",
#                                                      ifelse(df_for_circle$reg_region== "TF binding site", "#E67E22",
#                                                              ifelse(df_for_circle$reg_region== "Promoter", "#1ABC9C",
#                                                                      ifelse(df_for_circle$reg_region== "Exon", "#2C3E50",
#                                                                            ifelse(df_for_circle$reg_region== "Intron", "#56B4E9","#C0392B"))))))))

circos.clear()
# .par() start and gap degree for setting partial rings up!

pdf("Curved_gene_diagram_P_FULL.pdf") # change to _outlier if outlier is removed line3104; and _color if using coloured snps


circos.par("track.height" = 0.1, start.degree = 180 , gap.degree= 180, canvas.xlim =c(-1,1), canvas.ylim =c(-0.3,1)) # radius of all circles = 1 so this means 1/10 is each track
# Track 1 - Gene Information
circos.initialize(df_for_circle$chr_gtex, x = df_for_circle$position_gtex, xlim =c(min(gene_and_reg$Start), max(gene_and_reg$End))) # defining the x axis for the tracks
# next we add in a track
circos.track(df_for_circle$chr_gtex, y = df_for_circle$logp, 
             panel.fun = function(x, y) {
               # These 3 lines are alter the outer label (in this case chrNUMBER)
               circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] + mm_y(15),
                           CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
                           adj = c(0, 0.5), cex = 0.6)
               # These lines are really important and WILL need modifying to get it looking good on the circle, digits = number of significant figures
               # 
               circos.axis(labels.cex = 0.4, 
                           direction ="outside", 
                           major.at = seq(signif(gene_and_reg$Start[which.min(gene_and_reg$Start)], digits = 3), 
                                          signif(gene_and_reg$End[which.max(gene_and_reg$End)], digits = 3), 
                                          by = 100000)) 
               # These alter the y axis ticks and will again need altering
               circos.yaxis(labels.cex=0.4, 
                            labels.niceFacing = TRUE, side="right", 
                            at = seq(from =as.integer(min(df_for_circle$logp)), 
                                     to = as.integer(max(df_for_circle$logp)), 
                                     by = as.integer(max(df_for_circle$logp)/4)))
             }) 

circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$Start, ybottom=pmin, xright=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$End, ytop=pmax, col=gene_and_reg$color, border=NA)
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$End, ytop=pmax-0.25*(pmax-pmin), col="skyblue1", border="skyblue1")
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$End, ytop=pmax-0.25*(pmax-pmin), col="black", border="black")
circos.trackPoints(sectors=df_for_circle$chr_gtex, x=df_for_circle$position_gtex,y= df_for_circle$logp, pch = 25, cex = 0.3, col= "mediumblue") # add in col=df_for_circle$color 
circos.rect(xleft=scale_bar$x[1:nrow(scale_bar)-1], ybottom=min(df_for_circle$logp)-((max(df_for_circle$logp))/3), xright=scale_bar$x[2:nrow(scale_bar)], ytop=min(df_for_circle$logp)-((max(df_for_circle$logp))/5), col=scale_bar$colour, border=NA) #0-((max(df_for_circle$logp))/10)

dev.off()
```
##### CURVED PheWAS SNPs (p Value) after merge and LD removal + Colour
```{r Curved Gene diagrams PHEWAS_RED}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gene_diagram_output")
library(circlize) # in preamble too
# Similar to above, select relevent columns, remove duplicates and 



df_for_circle = df %>% dplyr::select(chr_gtex, position_gtex,reg_region, p)
df_for_circle = unique(df_for_circle)
df_for_circle$y = runif(nrow(df_for_circle)) # random y value between 0 and 1 - stddist
df_for_circle$logp = -log(df_for_circle$p)
# This dataset has one incredibly significant SNP so option to remove it for nicer plot here:
#df_for_circle = df_for_circle[which(df_for_circle$logp<400),]

pmax=df_for_circle$logp[which.max(df_for_circle$logp)]
pmin=df_for_circle$logp[which.min(df_for_circle$logp)]


# colours_for_rect = c("palegreen3","gray70","violet","cyan3","gold","red3","black","skyblue1")

gene_and_reg$color = ifelse( gene_and_reg$EI== "Enhancer", "#196F3D", 
                             ifelse(gene_and_reg$EI== "Open chromatin", "#AAB7B8",
                                     ifelse(gene_and_reg$EI== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(gene_and_reg$EI== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(gene_and_reg$EI== "TF binding site", "#E67E22",
                                                             ifelse(gene_and_reg$EI== "Promoter", "#1ABC9C",
                                                                     ifelse(gene_and_reg$EI== "Exon", "#2C3E50",
                                                                           ifelse(gene_and_reg$EI== "Intron", "#56B4E9","FAIL"))))))))

# Add in colours for snps:
df_for_circle$color = ifelse( df_for_circle$reg_region== "Enhancer", "#196F3D",
                             ifelse(df_for_circle$reg_region== "Open chromatin", "#AAB7B8",
                                     ifelse(df_for_circle$reg_region== "Promoter Flanking Region", "#ABEBC6",
                                             ifelse(df_for_circle$reg_region== "CTCF Binding Site", "#C39BD3",
                                                     ifelse(df_for_circle$reg_region== "TF binding site", "#E67E22",
                                                             ifelse(df_for_circle$reg_region== "Promoter", "#1ABC9C",
                                                                     ifelse(df_for_circle$reg_region== "Exon", "#2C3E50",
                                                                           ifelse(df_for_circle$reg_region== "Intron", "#56B4E9","#C0392B"))))))))

circos.clear()
# .par() start and gap degree for setting partial rings up!

pdf("Curved_gene_diagram_P_FULL_Colour.pdf") # change to _outlier if outlier is removed line3104; and _color if using coloured snps


circos.par("track.height" = 0.1, start.degree = 180 , gap.degree= 180, canvas.xlim =c(-1,1), canvas.ylim =c(-0.3,1)) # radius of all circles = 1 so this means 1/10 is each track
# Track 1 - Gene Information
circos.initialize(df_for_circle$chr_gtex, x = df_for_circle$position_gtex, xlim =c(min(gene_and_reg$Start), max(gene_and_reg$End))) # defining the x axis for the tracks
# next we add in a track
circos.track(df_for_circle$chr_gtex, y = df_for_circle$logp, 
             panel.fun = function(x, y) {
               # These 3 lines are alter the outer label (in this case chrNUMBER)
               circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] + mm_y(15),
                           CELL_META$sector.index, facing = "clockwise", niceFacing = TRUE,
                           adj = c(0, 0.5), cex = 0.6)
               # These lines are really important and WILL need modifying to get it looking good on the circle, digits = number of significant figures
               # 
               circos.axis(labels.cex = 0.4, 
                           direction ="outside", 
                           major.at = seq(signif(gene_and_reg$Start[which.min(gene_and_reg$Start)], digits = 3), 
                                          signif(gene_and_reg$End[which.max(gene_and_reg$End)], digits = 3), 
                                          by = 100000)) 
               # These alter the y axis ticks and will again need altering
               circos.yaxis(labels.cex=0.4, 
                            labels.niceFacing = TRUE, side="right", 
                            at = seq(from = as.integer(min(df_for_circle$logp)), 
                                     to = as.integer(max(df_for_circle$logp)), 
                                     by = as.integer(max(df_for_circle$logp)/4)))
             }) 

circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$Start, ybottom=pmin, xright=gene_and_reg[which(gene_and_reg$EI != "Exon" & gene_and_reg$EI != "Intron"),]$End, ytop=pmax, col=gene_and_reg$color, border=NA)
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Intron"),]$End, ytop=pmax-0.25*(pmax-pmin), col="skyblue1", border="skyblue1")
circos.rect(xleft=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$Start, ybottom=pmin+0.25*(pmax-pmin), xright=gene_and_reg[which(gene_and_reg$EI == "Exon"),]$End, ytop=pmax-0.25*(pmax-pmin), col="black", border="black")
circos.trackPoints(sectors=df_for_circle$chr_gtex, x=df_for_circle$position_gtex,y= df_for_circle$logp, pch = 25, cex = 0.3,col=df_for_circle$color) # add in col=df_for_circle$color 
circos.rect(xleft=scale_bar$x[1:nrow(scale_bar)-1], CELL_META$cell.ylim[1] - mm_y(1.5), xright=scale_bar$x[2:nrow(scale_bar)], ytop=CELL_META$cell.ylim[1], col=scale_bar$colour, border=NA) #0-((max(df_for_circle$logp))/10)

dev.off()
```


####5. Graphs of where the SNPS are: (quick look before circos)
Next I'd like to plot the  bar chart of each reg/genetic element as a basic visualisation of what's going on.
```{r bar plot _G_P bar chart of reg region count}
Unique_snps = df %>% dplyr::select( rsid, Intron_or_Exon, reg_region)
Unique_snps = unique(Unique_snps)
Unique_snps$reg_region = factor(Unique_snps$reg_region,levels = c("CTCF Binding Site", "Enhancer","Open chromatin","TF binding site", "Promoter", "Promoter Flanking Region", "None"))


snpvsregion = ggplot(Unique_snps, aes(x = reg_region, fill = Intron_or_Exon))+
  geom_bar(alpha=0.8, position = position_dodge2(width = 1, preserve = "single"))+#  alpha is transparancy from 0-1
  scale_fill_viridis_d(direction=1, option = "magma", end=0.6, name ="Intron, Exon or Neither") + # I like this palette but you can remove it or change it 
  labs(title= "Number of Unique SNPs in Each Type of Genomic Region" , x= "Regulatory Region", y= "Count", caption = paste("Overall number of SNPs =", nrow(Unique_snps)))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))
snpvsregion

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/REG_region_counts") #SAVE it
ggsave("RegRegion_COUNT_G_P.pdf") # simple gene structure
```


Next I'd like to plot the  bar chart of each reg/genetic element as a basic visualisation of what's going on.
```{r Bar plot_G bar chart of reg region count}

Unique_snps = Gtex %>% dplyr::select(rsid, Intron_or_Exon, reg_region)
Unique_snps = unique(Unique_snps)
# Next line sets the order on the bar chart - levels will needed changing based on what your results are
# You have to add in extras as and when you need them
Unique_snps$reg_region = factor(Unique_snps$reg_region,levels = c("CTCF Binding Site", "Enhancer","Open chromatin","TF binding site", "Promoter", "Promoter Flanking Region", "None"))



snpvsregion = ggplot(Unique_snps, aes(x = reg_region, fill = Intron_or_Exon))+
  geom_bar(alpha=0.8, position = position_dodge2(width = 1, preserve = "single"))+#  alpha is transparancy from 0-1
  scale_fill_viridis_d(direction=1, option = "magma", end=0.6, name ="Intron, Exon or Neither") + # I like this palette but you can remove it or change it 
  labs(title= "Number of Unique SNPs in Each Type of Genomic Region" , x= "Regulatory Region", y= "Count", caption = paste("Overall number of SNPs =", nrow(Unique_snps)))+ #labels
  theme(axis.text.x = element_text(angle = 45, hjust =1))
snpvsregion

setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex/Plots/REG_region_counts") #SAVE it
ggsave("RegRegion_COUNT_G.pdf") # simple gene structure


```
### INCOMPLETE - Circos
This section will not be nearly as automated due to the individuality gene to gene. It is a little difficult to get started so here are some examples with "circlize" package. There is a very comprehensive e-book on this package: https://jokergoo.github.io/circlize_book/book/ that has been invaluable to getting these plots working.

Step 1, load in the dataframes you want. In my case that's the full merged df and the Gtex original df. This will allow me to look at links between the position, tissue group, trait group before and after merge.

NOTE: this is reliant on the Ensembl subfolder - made in the GENE DIAGRAM section 
```{r for circos data load in}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Ensembl")
reg_feat = read_csv("YOUR_GENE_NAME_full_REG_region.csv")
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
df = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")
Gtex = read_csv("YOUR_GENE_NAME_Gtex_cleaned_REG.csv")
setwd("C:/Users/Harry Young/Documents/Local Wokr/Trait and Tissue Groups")
Full_tissue_database = read_csv("Full_tissue_database.csv") 

```
Step 2, This Gtex dataframe doesn't have the tissue groups bound so we need to do that and save it:
```{r gtex tissue group assign}
 Gtex$tissue_group = Gtex$Tissue ## duplicate the search column
 Gtex$tissue_group_secondary = "NA"
 
 for( n in 1:nrow(Gtex)){# goes through each tissue group and binds these to the original data set
   for( i in 1:nrow(Full_tissue_database)){
     if(Gtex$tissue_group[n] == Full_tissue_database$RAW_Tissue[i]){
       Gtex$tissue_group[n] =  Full_tissue_database$Tissue[i]
       Gtex$tissue_group_secondary[n] =  Full_tissue_database$Secondary[i]
     }
   }
 }
 
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
write_csv(Gtex, "YOUR_GENE_NAME_Gtex_cleaned_REG.csv")
```
Step 3, Now we are going to go through and plot each circos plot first. NOTE: this section uses the generic df name "test" as the frequency table that each circos plot is made from. This means each chunk will override this test table. If you would like to save it then use writetsv(test, "filename.tsv"). But they are quick and easy to make and not much point commiting to memory I've found.

I've also included a chunk with the list format for grid_col, I use a html colour picker to grab colours I want but you can also use circlize's inbuilt col_mat = rand_color(length(test)) (meaning assign random colours for the length of that generic frequency matrix "test") COLOUR STORAGE:

NOTE: The issue here is circlize isn't really cut out for assigning specific colours to lots of things to be consistent between plots. So this colour chunk below is my over-the-top way of assigning specific colours to EVERYTHING. This means that for every new gene I make a new grid_col dataframe, compare grid_col and the list of traitgroups/tissuesgroups for the new gene and see if I need to add any and which I need to comment out.

```{r Storage for Colour}
# Correcting  df  names to actually be plottable

# FUll colour list
grid_col = c(`Body Fat/Size` = "#0DF485",
            `Metabolism (inc. Diabetes)` = "#0DF4BF",
             `Tumours (Benign/Cancer)` = "#32DCC1",
             `Atrophy/Dystrophy` = "#32CCDC",
            `Congenital Defects` = "#0DB5F4",
             `Cardiovascular Traits` = "#3277DC",
             `Blood/Vascular Traits` ="#4532DC",
             Inflammation ="#9A32DC", #  or #AA98A970
            `Respiratory` ="#C432DC",
             `Renal/Urinary` = "#DC32D0",
            `Physical Activity` = "#DC324D",
             `Digestive Traits` ="#DC4132",
            `Nervous System/Brain` = "#DC5D32",
             `Bone Traits (inc. Dental)` = "#DC8732",
            `Muscular/Tendon Traits` = "#DCA732",
            `Physical Injury` = "#DCD232",
            `Alcohol-related Disease` ="#BCDC32",
             `Life Span` ="#92DC32",
             `Female Specific Traits` = "#43DC32",
            `Other/Unspecified` ="#C9C7BD",
             # Tissues:
             Blood = "#CC5500",
             `Cultured Cells` = "#00FFFF",
             Digestive ="#A7C7E7",
             Endocrine = "#FF4433",
             Fat = "#E0115F",
             `Female Reproductive Tissue` = "#0C5F7D",
             Heart = "#80461B",
             Lymphatic ="#023020",
             `Male Specific Tissue` ="#FFA500",
             Mammary = "#E9846E",
             Muscle = "#FFBF00",
             Nervous = "#90EE90",
             `Respiratory Tissue` = "#D673C9",
             Skin = "#00A36C",
             Vascular ="#630330"
             
)

# selects just the names from grid_col - Tissuegroup/traitgroup
colour_data = names(grid_col)
# selects tissue/tratgroups from main df
new_groups = append(unique(df$traitgroup), unique(df$tissue_group))
print(new_groups)
# 
to_add = setdiff(new_groups, colour_data) # data unique to colour data
to_comment_out = setdiff(colour_data, new_groups)


## Loop to correct out a spelling mistake
# for(n in 1:nrow(df)){
#   if(df$traitgroup[n] == "Neuorological_Function_OR_Brain_Traits"){
#     df$traitgroup[n] = "Neurological_Function_OR_Brain_Traits"
#   }
# }

###fairly random colour list#######
#2E9AFE
#800020
#00FFFF - cyan
#301934
#CBC3E3
#7FFFD4 - aqua
#AA98A9
#E0B0FF
#8A9A5B - sage green
#ACFA58
#800080
#7F00FF
#4169E1 - royal blue
#673147
#CC5500
#DF013A
#AA336A
#D70040
#A7C7E7 - pastel blue
#610B4B
#FF4433
#E0115F
#80461B
#023020 - dark green
#FFA500
#FFBF00
#90EE90
#610B0B
#00A36C
#630330 - tyrian purple

# for gene diagram split:
#9430c2 - purple
#bd680d - orange

# for other:
#808080 - grey
#F5F5DC - beige

```
Now we have two lists, one that tells which to add to grid_col as new groups (to_add) and the other telling us which to comment out (to_comment_out)
```{r}
print(to_add)
```

```{r}
print(to_comment_out)
# removes members of grid_col that overlap with the to comment out
grid_col = grid_col[!(names(grid_col) %in% to_comment_out)]

if(length(colour_data)-length(grid_col)==length(to_comment_out)){
  print("Removed all unnecersary colours as expected")
} else{ print("Something went wrong!")}
```

Now we make a new modified grid_col, copied from above to be modified. then simply put a '#' in front of each line you don't need:
```{r}

grid_col_trait = grid_col[1:length(unique(df$traitgroup))]

grid_col_tissue = grid_col[(length(unique(df$traitgroup))+1):(length(unique(df$traitgroup))+length(unique(df$tissue_group)))]

```

####1. Gtex raw: I've put some comments next to lines to explain what each parameter is to try and help you make your own but please do refer to that e-book I mentioned before for more detail.
THIS IS AN EXTRA PLOT THAT CAN CAUSE MORE TROUBLE THAN IS WORTH. This is because it is HUGE and so hard to read and often messes with grid_col because of differences between df and gtex... Feel free to run it but if it doesn't work try the steps i've put in below or SKIP :). - JUst for good measure it's slow too.

Very occasionally the Gtex RAW plot will have different tissues thant he rest as a snp for a tissue isn't found in the PHEWAS search. So double check the circos plot for any extra categories or if the colour has been playing silly buggers and adjust accordingly:
* Check carefully for any missing tissues that appear on the plot but not in your grid_col_tissue list.
* Comment in those tissues (by removing the "#")
* Rerun the previous chunk and then this one
* go back and comment back out the added tissue and rerun just teh previous chunk.

Sorry this is a little annoying but unfortunately it is the best I can do!
```{r circos one - Gtex RAW}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Circos")

# First selecting key columns from the Gtex dataframe (pre-merge)
 simple_LUT_G = Gtex %>% dplyr::select(position_gtex, Tissue, tissue_group, `P-Value`)
 
 
 # removing any duplicated values (unusual in this dataframe but worth doing)
 simple_LUT_G = unique(simple_LUT_G)
 # Now simplifying again to just position and tissue_group
 simple_LUT_G = simple_LUT_G %>% dplyr::select(position_gtex, tissue_group)
# table() returns a frequency matrix with position down y and tissue_group along x in this case named generically "test"
 test = table(simple_LUT_G)

# circlize works as follows : 1. initialise the environment (not needed for chordDiagram (links)); Plot track; plot extras ontop of track; add labels; PLot the next track in; etc... In this case we use chordDiagram to plot the links, then circos.track() for the labels. Circos.track is a generic call that allows you to define a function using panel.fun{}. Beyond my scope of knowledge so this is lifted directly from the e-book example
circos.clear() # generic: "Clear everything from the plotting environment" command
pdf("Position_Gtex_RAW.pdf")
chordDiagram(test, 
              annotationTrackHeight = c(0.01, 0.01), 
              annotationTrack = "grid",
              #big.gap =15,
              small.gap = 0.2,
              column.col = grid_col_tissue, # or col_mat
              grid.col = grid_col_tissue,
              diffHeight = mm_h(5), 
              # (length(unique(simple_LUT$tissue_group)))
              preAllocateTracks = list(track.height = 0.2*max(strwidth(unlist(dimnames(test))))),
              transparency = 0.5
 )
# This particular plot has SO many positions it makes the labels look a bit rubbish but I've kept them in anyway
circos.track(track.index = 1, panel.fun = function(x, y) {
   circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
               facing = "clockwise", niceFacing = TRUE, adj = c(-0.2, 0.5), cex =0.5)
}, bg.border = NA)
dev.off()
```


####2. Gtex (from merged df)
```{r Gtex from merged df circos 2}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Circos")

# First selecting key columns from the Gtex dataframe (pre-merge)
 simple_LUT_Gmerge = df %>% dplyr::select(position_gtex, Tissue, tissue_group, `P-Value`)
 

 # removing any duplicated values
 simple_LUT_Gmerge = unique(simple_LUT_Gmerge)
 # Now simplifying again to just position and tissue_group
 simple_LUT_Gmerge = simple_LUT_Gmerge %>% dplyr::select(position_gtex, tissue_group)
# table() returns a frequency matrix with position down y and tissue_group along x in this case named generically "test"
 test = table(simple_LUT_Gmerge)

# circlize works as follows : 1. initialise the environment (not needed for chordDiagram (links)); Plot track; plot extras ontop of track; add labels; PLot the next track in; etc... In this case we use chordDiagram to plot the links, then circos.track() for the labels. Circos.track is a generic call that allows you to define a function using panel.fun{}. Beyond my scope of knowledge so this is lifted directly from the e-book example
circos.clear() # generic: "Clear everything from the plotting environment" command
pdf("Position_Gtex_P.pdf")
circos.par(start.degree=-90) # Rotates the plot so tissues are on the right as they will in the final figure
chordDiagram(test, 
              annotationTrackHeight = c(0.01, 0.01), 
              annotationTrack = "grid",
              big.gap =15,
              small.gap = 1,
              column.col = grid_col_tissue, # or col_mat
              grid.col = grid_col_tissue,
              diffHeight = mm_h(5), 
              # (length(unique(simple_LUT$tissue_group)))
              preAllocateTracks = list(track.height = 0.2*max(strwidth(unlist(dimnames(test))))),
              transparency = 0.5
 )
# This particular plot has SO many positions it makes the labels look a bit rubbish but I've kept them in anyway
circos.track(track.index = 1, panel.fun = function(x, y) {
   circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
               facing = "clockwise", niceFacing = TRUE, adj = c(-0.2, 0.5), cex =0.5)
}, bg.border = NA)
dev.off()
```

####3. Tissue-Traitgroup overlap: NOTE: For these next two the traitgroups are listed here with colours associated. Every gene will have a different list of traitgroups. Best to go through manually and modify accordingly, or use rand_color (see commented lines)
```{r tissue trait group overlap for circos 3}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Circos")
# This one Tissuegroup-traitgroup - uising the simple_LUT_COR

# OR using rand_color:
# col_mat = rand_color(length(test))
# col_mat = rand_color((2*length(unique(simple_LUT_COR$tissue_group))))
 
simple_LUT_COR = df %>% dplyr::select(tissue_group, traitgroup)


simple_LUT_COR$traitgroup = factor(simple_LUT_COR$traitgroup, levels = names(grid_col_trait))
simple_LUT_COR$tissue_group = factor(simple_LUT_COR$tissue_group, levels =names(grid_col_tissue))

test = table(simple_LUT_COR)

circos.clear()
pdf("Tissue_trait_overlap.pdf")
circos.par( start.degree = -90 ) 
chordDiagram(test, 
             annotationTrackHeight = c(0.01, 0.01), 
             annotationTrack = "grid",
             big.gap =15,
            #small.gap = 1,
             column.col = grid_col, # or col_mat
            grid.col = grid_col,
             diffHeight = mm_h(5), 
              # (length(unique(simple_LUT$tissue_group)))
             preAllocateTracks = list(track.height = 0.2*max(strwidth(unlist(dimnames(test))))),
            transparency = 0.5,
            order = c(rev(rownames(test)), colnames(test)) # sets order (reverse order for tissues for nice plot)
            )
circos.track(track.index = 1, panel.fun = function(x, y) {
  circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
              facing = "clockwise", niceFacing = TRUE, adj = c(-0.2, 0.5), cex =0.5)
}, bg.border = NA)
dev.off()
```

####3b. Tissue-Traitgroup overlap NO OTHER: 
```{r tissue trait group overlap for circos 3b}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Circos")
# This one Tissuegroup-traitgroup - uising the simple_LUT_COR

# OR using rand_color:
# col_mat = rand_color(length(test))
# col_mat = rand_color((2*length(unique(simple_LUT_COR$tissue_group))))
temp = df[which(df$traitgroup!= "Other/Unspecified"),]
 
simple_LUT_COR = temp %>% dplyr::select(tissue_group, traitgroup)


simple_LUT_COR$traitgroup = factor(simple_LUT_COR$traitgroup, levels = names(grid_col_trait))
simple_LUT_COR$tissue_group = factor(simple_LUT_COR$tissue_group, levels =names(grid_col_tissue))

test = table(simple_LUT_COR)

circos.clear()
pdf("Tissue_trait_overlap_NO_OTHER.pdf")
circos.par( start.degree = -90 ) 
chordDiagram(test, 
             annotationTrackHeight = c(0.01, 0.01), 
             annotationTrack = "grid",
             big.gap =15,
            #small.gap = 1,
             column.col = grid_col, # or col_mat
            grid.col = grid_col,
             diffHeight = mm_h(5), 
              # (length(unique(simple_LUT$tissue_group)))
             preAllocateTracks = list(track.height = 0.2*max(strwidth(unlist(dimnames(test))))),
            transparency = 0.5,
            order = c(rev(rownames(test)), colnames(test)) # sets order (reverse order for tissues for nice plot)
            )
circos.track(track.index = 1, panel.fun = function(x, y) {
  circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
              facing = "clockwise", niceFacing = TRUE, adj = c(-0.2, 0.5), cex =0.5)
}, bg.border = NA)
dev.off()
```

####4. Traitgroup to Position overlap
```{r traitggroup to position overlap circos 4}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Circos")

simple_LUT_P = df %>% dplyr::select(position_gtex, traitgroup, p)


simple_LUT_P$traitgroup = factor(simple_LUT_P$traitgroup, levels = names(grid_col_trait))

simple_LUT_P = unique(simple_LUT_P)
simple_LUT_P = simple_LUT_P %>% dplyr::select(position_gtex, traitgroup)

test = table(simple_LUT_P)
 

circos.clear()
pdf("trait_position.pdf")
circos.par( start.degree = 90 ) 
chordDiagram(test, 
              annotationTrackHeight = c(0.01, 0.01), 
              annotationTrack = "grid",
              big.gap =10,
              #small.gap = 1,
              column.col = grid_col_trait, # or col_mat
              grid.col = grid_col_trait,
              diffHeight = mm_h(5), 
              # (length(unique(simple_LUT$tissue_group)))
              preAllocateTracks = list(track.height = 0.2*max(strwidth(unlist(dimnames(test))))),
              transparency = 0.5,
              order = c(rownames(test), rev(colnames(test)))
 )
 circos.track(track.index = 1, panel.fun = function(x, y) {
   circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
               facing = "clockwise", niceFacing = TRUE, adj = c(-0.2, 0.5), cex =0.5)
 }, bg.border = NA)

dev.off()

```

####4b.Traitgroup_pos overlap NO OTHER: 
```{r tissue trait group overlap for circos 4b}
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Circos")
# This one Tissuegroup-traitgroup - uising the simple_LUT_COR

# OR using rand_color:
# col_mat = rand_color(length(test))
# col_mat = rand_color((2*length(unique(simple_LUT_COR$tissue_group))))
temp = df[which(df$traitgroup!= "Other/Unspecified"),]
 
simple_LUT_P = temp %>% dplyr::select(position_gtex, traitgroup, p)


simple_LUT_P$traitgroup = factor(simple_LUT_P$traitgroup, levels = names(grid_col_trait))

simple_LUT_P = unique(simple_LUT_P)
simple_LUT_P = simple_LUT_P %>% dplyr::select(position_gtex, traitgroup)

test = table(simple_LUT_P)
 

circos.clear()
pdf("trait_position_NO_OTHER.pdf")
circos.par( start.degree = 90 ) 
chordDiagram(test, 
              annotationTrackHeight = c(0.01, 0.01), 
              annotationTrack = "grid",
              big.gap =10,
              #small.gap = 1,
              column.col = grid_col_trait, # or col_mat
              grid.col = grid_col_trait,
              diffHeight = mm_h(5), 
              # (length(unique(simple_LUT$tissue_group)))
              preAllocateTracks = list(track.height = 0.2*max(strwidth(unlist(dimnames(test))))),
              transparency = 0.5,
              order = c(rownames(test), rev(colnames(test)))
 )
 circos.track(track.index = 1, panel.fun = function(x, y) {
   circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
               facing = "clockwise", niceFacing = TRUE, adj = c(-0.2, 0.5), cex =0.5)
 }, bg.border = NA)

dev.off()

```

### INCOMPLETE - SANKEY
Alternative format for several circos plots is one big sankey diagram using
#### big link diagram
Here I've had a play with some various options, I quite like the sankey diagram approach. This is a much more hands on way of producing a plot so a lot of code to comment INCOMPLETE

This is a little.... forced. I can't control where the labels go which is really annoying me. I think I'm going to stick with the circos plots... However it is a nice plot so I've left the code here, you can tweak it if you like and I find it's best running this using ctrl enter of the highlighted box as opposed to using the play button of the chunk. THis means it'll appear in Rstudios plot window and you can save it as a Html quite nicely.
```{r, eval=F, include =F}
library(circlize)
library(plotly)
library(tidyverse)
setwd("C:/Users/Harry Young/Documents/Local Wokr/YOUR_GENE_NAME_test/Gtex")
Gtex_RED = read_csv("YOUR_GENE_NAME_Gtex_cleaned_REG.csv")
df_final = read_csv("YOUR_GENE_NAME_gtexPHEWAS_no_ukaORAmbig_FINAL_LINKEDREMOVEDr20.5.csv")
df =df_final
# Sort all the traitgroup names so they don't overlap with tissues
# # loops to change trait names to include _traits for clarity
# for (n in 1:nrow(df)){
#   if (df$traitgroup[n] =="Blood"){
#     df$traitgroup[n] ="Blood Traits"
#   }
# }
# for (n in 1:nrow(df)){
#   if (df$traitgroup[n] =="Vascular"){
#     df$traitgroup[n] ="Vascular Traits"
#   }
# }
# for (n in 1:nrow(df)){
#   if (df$traitgroup[n] =="Kidney"){
#     df$traitgroup[n] ="Kidney Traits"
#   }
# }
# for (n in 1:nrow(df)){
#   if (df$traitgroup[n] =="Bone"){
#     df$traitgroup[n] ="Bone Traits"
#   }
# }
# for (n in 1:nrow(df)){
#   if (df$traitgroup[n] =="Eye"){
#     df$traitgroup[n] ="Eye Traits"
#   }
# }

# This is a little complicated with all the labels shifting around.... 
# Essentially, because this last step is backwards, trait to position
# and because we're having to reassign new 'node' values for all of these
# fake positions using "_2". 
# POSITION
position = df$position_gtex
position = sort(position)
position = as.data.frame(position)
position= unique(position)
position$source = c(1:nrow(position))
names(position) = c("label", "source")
## tissue group
tissuegroup =df$tissue_group
tissuegroup = sort(tissuegroup)
tissuegroup = as.data.frame(tissuegroup)
tissuegroup= unique(tissuegroup)
tissuegroup$source = c(nrow(position)+1:nrow(tissuegroup))
names(tissuegroup) = c("label", "source")
## trait group
traitgroup =df$traitgroup
traitgroup = sort(traitgroup)
traitgroup = as.data.frame(traitgroup)
traitgroup= unique(traitgroup)
traitgroup$source = tissuegroup$source[nrow(tissuegroup)]+1:nrow(traitgroup)
names(traitgroup) = c("label", "source")
# add in all nodes list at this point
# adding in a second position set of nodes:
position2 = df$position_gtex
position2 = sort(position2)
position2 = as.data.frame(position2)
position2= unique(position2)
position2$source = traitgroup$source[nrow(traitgroup)]+1:nrow(position2)
names(position2) = c("target", "source") # note target not label in this case, need to change it back later!
## unique identifier for this second set
position2$target = paste0(position2$target, "_2")


# Overall idea Genediagram - POSITION - Tissue - Trait - Position -  gene diagram

# not needed
# ## position-traitgroup
# position_traitgroup = df %>% select(position_gtex, traitgroup, p)
# position_traitgroup = unique(position_traitgroup)# select all the unique links
# position_traitgroup =position_traitgroup[,1:2]
# position_traitgroup = position_traitgroup[order(position_traitgroup$position_gtex),]
# position_traitgroup_freq = count(position_traitgroup, position_gtex,traitgroup)
# names(position_traitgroup_freq) = c("label", "target", "value")
# position_traitgroup_freq = inner_join(position, position_traitgroup_freq, by = "label")
# names(position_traitgroup_freq) = c("label","source", "target", "value")

## position-tissuegroup
position_tissuegroup = df %>% dplyr::select(position_gtex, tissue_group, `P-Value`)
position_tissuegroup = unique(position_tissuegroup)# select all the unique links
position_tissuegroup =position_tissuegroup[,1:2]
position_tissuegroup = position_tissuegroup[order(position_tissuegroup$position_gtex),]
position_tissuegroup_freq = count(position_tissuegroup, position_gtex,tissue_group)
position_tissuegroup_freq = position_tissuegroup_freq[order(position_tissuegroup_freq$position_gtex),]

# setting temporary names so we can bind effectively 
names(position_tissuegroup_freq) = c("label", "target", "value")
position_tissuegroup_freq = inner_join(position, position_tissuegroup_freq, by = "label")

#quick source adjustment for the weird counting of sankey:
position_tissuegroup_freq$source =position_tissuegroup_freq$source-1
#renaming so it actually makes sense
position_tissuegroup_freq = position_tissuegroup_freq %>% rename(source = label,
                                                                 origin = source)

## Tissue group to traitgroup
tissuegroup_traitgroup = df %>% dplyr::select(tissue_group, traitgroup)
tissuegroup_traitgroup_freq = count(tissuegroup_traitgroup, tissue_group,traitgroup)
tissuegroup_traitgroup_freq = tissuegroup_traitgroup_freq[order(tissuegroup_traitgroup_freq$tissue_group),]

# setting temporary names so we can bind effectively 
names(tissuegroup_traitgroup_freq) = c("label", "target", "value")
tissuegroup_traitgroup_freq = inner_join(tissuegroup_traitgroup_freq, tissuegroup, by = "label")
#quick source adjustment for the weird counting of sankey:
tissuegroup_traitgroup_freq$source =tissuegroup_traitgroup_freq$source-1
#renaming so it actually makes sense
tissuegroup_traitgroup_freq = tissuegroup_traitgroup_freq %>% rename(source = label,
                                                                 origin = source)

## adding in position2-traitgroup
# This time we have to assign the source number at this stage
traitgroup_position2 = df %>% dplyr::select(traitgroup, position_gtex, p)
traitgroup_position2 = unique(traitgroup_position2)# select all the unique links
traitgroup_position2 =traitgroup_position2[,1:2]
traitgroup_position2 = traitgroup_position2[order(traitgroup_position2$position_gtex),]
traitgroup_position2_freq = count(traitgroup_position2, traitgroup,position_gtex)
traitgroup_position2_freq = traitgroup_position2_freq[order(traitgroup_position2_freq$position_gtex),]

# setting temporary names so we can bind effectively 
names(traitgroup_position2_freq) = c("label", "target", "value")
## unique identifier for this second set repeated here
traitgroup_position2_freq$target = paste0(traitgroup_position2_freq$target, "_2")
traitgroup_position2_freq = inner_join(traitgroup_position2_freq, position2, by = "target")

#quick source adjustment for the weird counting of sankey:
traitgroup_position2_freq$source =traitgroup_position2_freq$source-1
#renaming so it actually makes sense
traitgroup_position2_freq = traitgroup_position2_freq %>% rename(source = label,
                                                                 origin = source)

## Full list of nodes

#all_nodes_backup=all_nodes

names(position2) = c("label", "source") # renaming target back to label 
all_nodes =rbind(position, tissuegroup,traitgroup, position2)
all_nodes$source = all_nodes$source-1#REALLY annoyingly, this starts indexing from 0 ....

## assigning a random colour for everything
all_nodes$color = rand_color(nrow(all_nodes), transparency = 0.5)
#Colour change test - swapping the other and other gene expression change to something less obvious
for(n in 1:nrow(all_nodes)){
  if(all_nodes$label[n] == "Other" | all_nodes$label[n] == "Other Gene Expression Change"){
    all_nodes$color[n] = "#F5F2E060"
  }
}




#binding them all together:
freq_table = rbind( position_tissuegroup_freq, tissuegroup_traitgroup_freq, traitgroup_position2_freq)
numeric_freq_table = freq_table
numeric_freq_table$color ="gray"
# getting the data into a purely numerical format
for(n in 1:nrow(freq_table)){
  for(i in 1:nrow(all_nodes)){
    if(freq_table$source[n] ==all_nodes$label[i]){
      numeric_freq_table$source[n] = all_nodes$source[i]
      if(numeric_freq_table$origin[n]>=nrow(position)-1){
        numeric_freq_table$color[n] = all_nodes$color[i] # assigns a colour based on the source
      }
    }
    else if(freq_table$target[n] == all_nodes$label[i]){
      numeric_freq_table$target[n] = all_nodes$source[i]
      if(numeric_freq_table$origin[n]<=nrow(position)-1){
        numeric_freq_table$color[n] = all_nodes$color[i] #assigns a color based on the destination
      }
    }
  }
}
# Now to assign SNP colour based upon destination too, make it a bit clearer INCOMPLETE



numeric_freq_table$source = as.numeric(numeric_freq_table$source)
numeric_freq_table$target = as.numeric(numeric_freq_table$target)
numeric_freq_table = numeric_freq_table[order(numeric_freq_table$source,numeric_freq_table$target),]


### Adding specific x y coordinates if needed - Will need to do this for RSID column at least - ideally proportional to real position
#First lines creating new weighted valuies for position setting
origin_weight = freq_table %>% group_by(source) %>%
   summarize(value = sum(value))

target_weight = freq_table %>% group_by(target) %>%
   summarize(value = sum(value))
target_weight = target_weight[grepl("_2", target_weight$target),]

all_nodes$value = 0
for(n in 1:nrow(all_nodes)){
   for(i in 1:nrow(origin_weight)){
      if(all_nodes$label[n] == origin_weight$source[i]){
         all_nodes$value[n] =origin_weight$value[i]
      }
   }
   for(j in 1:nrow(target_weight)){
      if(all_nodes$label[n] == target_weight$target[j]){
         all_nodes$value[n] =target_weight$value[j]
      }
   }
}
# setting up column identifiers - as in which column it'll sit in in the sankey diagram:
all_nodes$column="FAIL"
all_nodes$column[1:nrow(position)] = 1
all_nodes$column[(nrow(position)+1):(nrow(position)+nrow(tissuegroup))] = 2
all_nodes$column[(nrow(position)+nrow(tissuegroup)+1):(nrow(position)+nrow(tissuegroup)+nrow(traitgroup))]   =3
all_nodes$column[(nrow(position)+nrow(tissuegroup)+nrow(traitgroup)+1):nrow(all_nodes)] = 4

# total links for setting up relative position
column_totals = all_nodes %>% group_by(column) %>%
   summarize(value = sum(value))
# split into 4 dataframes (per column)
temp1 = all_nodes[which(all_nodes$column == 1),]
temp2 = all_nodes[which(all_nodes$column == 2),]
temp3 = all_nodes[which(all_nodes$column == 3),]
temp4 = all_nodes[which(all_nodes$column == 4),]

# setting up a cumulative frequency column
temp1 = transform(temp1, cumFreq = cumsum(value))
temp2 = transform(temp2, cumFreq = cumsum(value))
temp3 = transform(temp3, cumFreq = cumsum(value))
temp4 = transform(temp4, cumFreq = cumsum(value))
# an equation to find an appropriate coordinate for the box
temp1$y = (temp1$value-1)/2+((temp1$cumFreq-temp1$value)+1)
temp1$y = temp1$y/column_totals$value[1]
temp2$y = (temp2$value-1)/2+((temp2$cumFreq-temp2$value)+1)
temp2$y = temp2$y/column_totals$value[2]
temp3$y = (temp3$value-1)/2+((temp3$cumFreq-temp3$value)+1)
temp3$y = temp3$y/column_totals$value[3]
temp4$y = (temp4$value-1)/2+((temp4$cumFreq-temp4$value)+1)
temp4$y = temp4$y/column_totals$value[4]

all_nodes =rbind(temp1,temp2,temp3,temp4)
all_nodes$y = as.numeric(all_nodes$y)
# OLD COORDINATE SYSTEM
# all_nodes$y = all_nodes$label # set y as the label (the position number)
# # for every position assign a y coordinate between 0.01 and 1 in the number of steps as there are positions
# all_nodes$y[1:nrow(position)] = seq(0.01, 1, by = 1/nrow(position))[1:nrow(position)]
# all_nodes$y[(nrow(position)+1):(nrow(position)+nrow(tissuegroup))] = seq(0.01, 1, by = 1/nrow(tissuegroup))[1:nrow(tissuegroup)]
# all_nodes$y[(nrow(position)+nrow(tissuegroup)+1):(nrow(position)+nrow(tissuegroup)+nrow(traitgroup))]   =seq(0.01, 1, by = 1/nrow(traitgroup))[1:nrow(traitgroup)]
# all_nodes$y[(nrow(position)+nrow(tissuegroup)+nrow(traitgroup)+1):nrow(all_nodes)] = seq(0.01, 1, by = 1/nrow(position))[1:nrow(position)]
# all_nodes$y = as.numeric(all_nodes$y)

# They y positions are still a little janky, maybe i can give them a weighted position based on their frequency (i.e. how big the box is)

all_nodes$x = ifelse( all_nodes$source<nrow(position), 0.2,
                      ifelse(all_nodes$source<nrow(position)+nrow(tissuegroup), 0.4,
                             ifelse(all_nodes$source<nrow(position)+nrow(tissuegroup)+nrow(traitgroup),0.6, 0.8)))
all_nodes$x = as.numeric(all_nodes$x)

# all_nodes$y = all_nodes$label
# all_nodes$y = ifelse( all_nodes$source<nrow(position) , (1:nrow(position))/nrow(position),
#                       ifelse(all_nodes$source<nrow(position)+nrow(tissuegroup), (1:nrow(tissuegroup))/nrow(tissuegroup), (1:nrow(traitgroup))/nrow(traitgroup)))
# all_nodes$y = as.numeric(all_nodes$y)
#ordering for structure of sankey diagram
all_nodes$source =as.numeric(all_nodes$source)
all_nodes = all_nodes[order(all_nodes$source),]

# clean up the "_2"
all_nodes$label = sub("_2", "", all_nodes$label)



library(plotly)

fig <- plot_ly(
  type = "sankey",
  arrangement = "perpindicular",
  domain = list(
    x =  c(0,1),
    y =  c(0,1)
  ),
  orientation = "h",
  
  
  node = list(
    label = all_nodes$label,
    color = all_nodes$color,
    x = all_nodes$x,
    y = all_nodes$y,
    pad = 1,
    thickness = 15,
    line = list(
      width = 0.1
    )
  ),
  
  link = list(
    source = numeric_freq_table$source,
    target = numeric_freq_table$target,
    value =  numeric_freq_table$value,
    color = numeric_freq_table$color
  )
)

fig <- fig %>% layout(
  title = "Basic Sankey Diagram",
  font = list(
    size = c(7),
    color = "white"
    
  ),
  xaxis = list(showgrid = F, zeroline = F),
  yaxis = list(showgrid = F, zeroline = F)
  #plot_bgcolor = 'white',
  #paper_bgcolor = '#696969'
)

fig
```


# COMMON ERRORS
'Error: 'YOUR_GENE_NAME_Dprime.csv' does not exist' - You need to run this chunk (CHUNK 7 - r Automated r2 and d prime START dataset, eval= FALSE, include=FALSE) of code seperately using the little play symbol. I've done this because it can be a lengthy step and is optional (only use if you have less than 999 uniques SNPs)


